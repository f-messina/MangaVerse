\chapter{Implementation}

\section{Development Environment}

The implementation of the MangaVerse web application was carried out in a development environment
chosen from the requirements and the design study precedently discussed. 
That includes the following tools and technologies:

\subsection{Programming Languages}
\begin{itemize}
    \item \textbf{Backend:} Java.
    \item \textbf{Frontend:} HTML, CSS, JavaScript.
    \item \textbf{Data Preprocessing:} Python and Java. 
\end{itemize}

\subsection*{Database}
\begin{itemize}
    \item \textbf{Document Database:} MongoDB\@.
    \item \textbf{Graph Database:} Neo4j.
\end{itemize}

\subsection*{Integrated Development Environment} 
\begin{itemize}
    \item Intellij IDEA\@.
\end{itemize}

\subsection*{Collaborative Development Environment}
\begin{itemize}
    \item Git.
    \item GitHub.
\end{itemize}

\subsection*{Web Server} 

\begin{itemize}
    \item Apache Tomcat.
\end{itemize}

\subsection*{Build Automation}

\begin{itemize}
    \item Maven.
\end{itemize}

\subsection*{Testing}

\begin{itemize}
    \item JUnit.
\end{itemize}

\newpage

\section{Main Modules}
\begin{itemize}
    \item Configuration
    \item Controller
    \item DAO (Data Access Objects)
    \item DTO (Data Transfer Objects)
    \item Model 
    \item Service
    \item Utils
    \item User Interface (JSP, CSS ans JS files)
\end{itemize}

\subsection*{Configuration}

The configuration module includes a class named \textit{AppServletContextListener}, which is responsible 
for managing \textbf{database connections}, the \textbf{TaskManager} for handling asynchronous operations and their priorities, 
and the \textbf{PeriodicExecutorTaskService} for handling periodic tasks. This configuration class implements 
the \textit{ServletContextListener} interface.

\vspace{\baselineskip}

\sloppy
The \textit{@WebListener} annotation is used to listen for application lifecycle events. 
The \textit{ServletContextListener} interface contains two methods: \textit{contextInitialized(ServletContextEvent sce)} 
and \textit{contextDestroyed(ServletContextEvent sce)}. 

\vspace{\baselineskip}

The \textit{contextInitialized} method is called when the web application starts. It opens the database 
connections and initiates the TaskManager and PeriodicExecutorTaskService. The \textit{contextDestroyed} 
method is invoked when the web application shuts down. It closes all database connections and stops the services.

\vspace{\baselineskip}

For MongoDB was used this configuration:

\begin{mdframed}[backgroundcolor=yellow!20, innerleftmargin=10pt, innerrightmargin=10pt]
    \begin{lstlisting}[language=java]
    settings = MongoClientSettings.builder()
                .applyConnectionString(connectionString)
                .writeConcern(WriteConcern.W1)
                .readPreference(ReadPreference.nearest())
                .retryWrites(true)
                .readConcern(ReadConcern.LOCAL)
                .build();
    \end{lstlisting}
\end{mdframed}

\begin{itemize}
    \item \textbf{WriteConcern.W1}: Write concern describes the level of acknowledgment requested from MongoDB for write operations. 
    WriteConcern.W1 means the write operation must be acknowledged by the primary server before the client proceeds. 
    This ensures that the data is written to at least the primary replica set member but doesn't wait for 
    acknowledgment from secondary members.
    \item \textbf{ReadPreference.nearest()}: Read preference determines how MongoDB clients route read operations 
    to members of a replica set. ReadPreference.nearest() means the client will read from the member of the replica 
    set that has the least network latency, irrespective of whether it's a primary or secondary member. This can help 
    reduce read latency.
    \item \textbf{retryWrites(true)}: RetryWrites enables retryable writes. If a network error occurs during a write 
    operation, MongoDB will automatically retry the write operation once. This can help to handle transient network 
    errors more gracefully.
    \item \textbf{ReadConcern.LOCAL}: Read concern specifies the level of isolation for read operations. 
    ReadConcern.LOCAL ensures that a query returns the most recent data a node has locally, without waiting 
    for data to be replicated to other nodes. This is the default level and it balances consistency and performance.
\end{itemize}

\subsection*{Controller}

The controller module acts as an intermediary between user requests and the backend of the MangaVerse web application 
through servlet classes. It receives user requests, processes them, and returns the corresponding responses. 
The controller classes are implemented using \textit{HttpServlet} to handle user requests and responses.

\vspace{\baselineskip}

In their intermediary role, the controller classes serve as a bridge between the user interface and backend logic. 
When a user interacts with the web application, their actions are translated into HTTP requests, which are handled 
by the relevant servlet class in the controller module. Each controller class utilizes a switch-case structure to 
determine the requested action and invokes the appropriate handler method accordingly. This structure allows for 
clear and organized routing of requests to their corresponding handler methods. After processing the request, the 
servlet generates the appropriate response.

\vspace{\baselineskip}

\textbf{Example code snippet from MediaContentServlet:}
\begin{mdframed}[backgroundcolor=yellow!20, innerleftmargin=10pt, innerrightmargin=10pt]
    \begin{lstlisting}[language=java]
{
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
        processRequest(request, response);
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
        processRequest(request, response);
    }

    protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
        switch (request.getParameter("action")) {
            case "editProfile" -> handleUpdate(request, response);
            case "deleteProfile" -> handleDelete(request, response);
            case "getReviews" -> handleGetReviewsByUserId(request, response);
            case "rateApp" -> handleRateApp(request, response);
            case "suggestedMediaContent" -> handleSuggestedMediaContent(request, response);
            case "suggestedUsers" -> handleSuggestedUsers(request, response);
            case null, default -> handleLoadPage(request, response);
        }
    }
}
    \end{lstlisting}
\end{mdframed}

The controller module contains the following classes:

\begin{itemize}
    \item \textbf{Exception:}
    \begin{itemize}
        \item \textbf{NotAuthorizedException:} This exception is thrown when the user is not authorized to access the requested resource.
    \end{itemize}
    \item \textbf{AuthServlet:} to handle rquests on authentication page.
    \item \textbf{MainPageServlet:} to handle requests on the mainPage.
    \item \textbf{ManagerServlet:} to handle requests on the manager page.
    \item \textbf{MediaContentServlet:} to handle requests on the media content page and retrieve or set media content releted info.
    \item \textbf{ProfileServlet:} to handle requests on the profile page.
    \item \textbf{UserServlet:} to handle requests related to user model.
\end{itemize}

\subsection*{DAO (Data Access Objects)}

The DAO module includes the logic for accessing and managing data in the database and provides data retrieval, 
storage and manipulation. This module includes classes with CRUD (create, read, update, delete) operations and query executions. 
It provides a layer of abstraction between the database and the rest of the application and ensures the separation of concerns. The DAO module contains the following classes:
\begin{itemize}
    \item Enums \\
    - DataRepositoryEnum
    \item Exceptions 
    \item Interfaces \\
    - MedÄ±aContentDAO \\
    - ReviewDAO \\
    - UserDAO 
    \item Mongo \\
    - AnimeDAOMongoImpl \\
    - BaseMongoDBDAO \\
    - MangaDAOMongoImpl \\
    - ReviewDAOMongoImpl \\
    - UserDAOMongoImpl 
    \item Neo4j \\
    - AnimeDAONeo4jImpl \\
    - BaseNeo4jDAO \\
    - MangaDAONeo4jImpl \\
    - UserDAONeo4jImpl 
    \item DAOLocator 
\end{itemize}

\newpage

\textbf{Example code snippet from MangaDAOMongoImpl:}
\begin{mdframed}[backgroundcolor=yellow!20, innerleftmargin=10pt, innerrightmargin=10pt]
    \begin{lstlisting}[language=java]
{
    //MongoDB queries
    //Best genres/themes/demographics/authors based on the average rating
    @Override
    public Map<String, Double> getBestCriteria (String criteria, boolean isArray, int page) throws DAOException {
        try  {
            MongoCollection<Document> mangaCollection = getCollection(COLLECTION_NAME);
            int pageOffset = (page-1)*Constants.PAGE_SIZE;

            List<Bson> pipeline;
            if (isArray) {
                pipeline = List.of(
                        match(and(exists(criteria), ne("average_rating", null))),
                        unwind("$" + criteria),
                        group("$" + criteria, avg("criteria_average_rating", "$average_rating")),
                        sort(descending("criteria_average_rating")),
                        skip(pageOffset),
                        limit(25)
                );
            } else {
                pipeline = List.of(
                        match(Filters.exists(criteria)),
                        group("$" + criteria, avg("criteria_average_rating", "$average_rating")),
                        sort(new Document("criteria_average_rating", -1)),
                        skip(pageOffset),
                        limit(25)
                );
            }

            List <Document> document = mangaCollection.aggregate(pipeline).into(new ArrayList<>());
            Map<String, Double> bestCriteria = new LinkedHashMap<>();
            for (Document doc : document) {
                Double avgRating = doc.get("criteria_average_rating") instanceof Integer?
                        doc.getInteger("criteria_average_rating").doubleValue() :
                        doc.getDouble("criteria_average_rating");
                if (criteria.equals("authors")) {
                    bestCriteria.put(doc.get("_id", Document.class).getString("name"), avgRating);
                } else {
                    bestCriteria.put(doc.get("_id").toString(), avgRating);
                }
            }

            return bestCriteria;

        } catch (Exception e) {
            throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
        }
    }
}
    \end{lstlisting}
\end{mdframed}

\newpage

\textbf{Example code snippet from UserDAONeo4jImpl:}
\begin{mdframed}[backgroundcolor=yellow!20, innerleftmargin=10pt, innerrightmargin=10pt]
    \begin{lstlisting}[language=java]
{
    /**
    * Retrieves a list of users following a specific user from the Neo4j database.
    *
    * @param userId The ID of the user whose followers are to be retrieved.
    * @param loggedUserId The ID of the user requesting the list of followers.
    * @return A list of RegisteredUserDTO objects representing the followers of the specified user.
    * @throws DAOException If an error occurs while retrieving the followers list.
    */
   @Override
   public List<UserSummaryDTO> getFirstNFollowers(String userId, String loggedUserId) throws DAOException {
       try (Session session = getSession()) {
           StringBuilder queryBuilder = new StringBuilder("MATCH (follower:User)-[:FOLLOWS]->(:User {id: $userId}) ");
           if (loggedUserId != null) {
               queryBuilder.append("WHERE follower.id <> $loggedUserId ");
           }
           queryBuilder.append("RETURN follower AS user ");
           queryBuilder.append("ORDER BY follower.username ");
           queryBuilder.append("LIMIT 10");
           String query = queryBuilder.toString();

           Map<String, Object> params = new HashMap<>();
           params.put("userId", userId);
           if (loggedUserId != null) {
               params.put("loggedUserId", loggedUserId);
           }

           List<Record> records = session.executeRead(
                   tx -> tx.run(query, params).list()
           );

           return records.isEmpty() ? null : records.stream()
                   .map(this::recordToUserSummaryDTO)
                   .toList();

       } catch (Neo4jException e) {
           throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());

       } catch (Exception e) {
           throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
       }
   }
}
    \end{lstlisting}
\end{mdframed}
\newpage


\subsection*{DTO (Data Transfer Objects)}
The DTO modules are the intermediary class between presentation layer and the DAO module in the web application.
They transfer data structures between different layers and components of the application in a more standardized way.


\subsection*{Model}
\begin{itemize}
    \item Enums
    \item Media Content \\
    - Anime\\
    - Manga \\
    - Manga Author \\
    - Media Content
    \item Registered User\\
    - Mangager\\
    - Registered User\\
    - User
    \item Review 
\end{itemize}

\subsection*{Service}
Service module has also important role in the web application. The classes in the service module are responsible for containing
the business logic and maintaining interaction between the DAO classes and the presentation layer. 
It handles complex operations with guarantying that the application's core functionalities are executed correctly. Some of the services
that are provided in the service module are: \textit{UserService, MediaContentService, ReviewService, TaskManager, ExecuterTaskService}. The 
package structure of Service module is as follows:

\begin{itemize}
    \item enums \\
    - ExecuterTaskService
    \item exceptions \\
    - enums \\
    ----- BusinessExceptionType \\
    - BusinessException
    \item impl \\
    - asinc media tasks\\
    ----- CreateMediaTask\\
    ----- DeleteMediaTask\\
    ----- UpdateAverageRatingTask\\
    ----- UpdateMediaRedundancyTask\\
    ----- UpdateMediaTask\\
    ----- UpdateNumberofLikesTask\\
    - asinc review tasks\\
    ----- RemoveDeletedMediaReviewsTask\\
    ----- RemoveDeletedUserReviewsTask\\
    ----- UpdateReviewRedundancyTask\\
    - asinc user tasks\\
    ----- CreateUserTask\\
    ----- DeleteUserTask\\
    ----- UpdateNumberOfFollowedTask\\
    ----- UpdateNumberOfFollowersTask\\
    ---- UpdateUserTask\\
    - AperiodicExecutorTaskServiceImpl\\
    - ErrorTaskManager\\
    - MediaContentServiceImpl\\
    - PeriodicExecutorTaskServiceImpl\\
    - ReviewServiceImpl\\
    - UserServiceImpl\\
    - interfaces \\
    ----- ExecuterTaskService\\
    ----- MediaContentService\\
    ----- ReviewService\\
    ----- Task\\
    ----- TaskManager\\
    ----- UserService
    \item ServiceLocator
\end{itemize}

\section{Adopted Patterns and Techniques}
\subsection*{Patterns}

\textbf{MVC Pattern}

The MVC (\textit{Model-View-Controller}) pattern is a prevalent architectural pattern in software development, especially in web 
applications. It divides the application into three interconnected components:

\begin{itemize}
\item \textbf{Model:} Represents the core data and business logic of the application. It interfaces with databases and processes 
data manipulation and business rules.

\item \textbf{View:} Handles the presentation layer of the application. It's responsible for rendering data to users and 
transmitting user interactions to the controller.

\item \textbf{Controller:} Acts as an intermediary between the model and view components. It receives user input, 
processes requests, and updates the model state accordingly. It then triggers updates to the view to reflect these changes.
\end{itemize}

\vspace{\baselineskip}

In addition to the MVC components, modern applications often integrate several additional modules to enhance organization and maintainability:

\begin{itemize}
\item \textbf{DAO (Data Access Object):} Handles access to different databases in an organized manner. It abstracts the data
access layer from the rest of the application, providing standardized methods for querying and manipulating data.

\item \textbf{Service:} Manages the application's business logic and acts as an intermediary between the controller and the 
DAO module. It encapsulates complex business rules and orchestrates multiple DAO accesses to execute operations requested by users.

\item \textbf{DTO (Data Transfer Object):} Facilitates the transfer of data between layers and modules of the application. 
DTOs are lightweight objects that carry data between the client and server, or between different layers of the application. 
They streamline communication and reduce the amount of data transmitted over the network.
\end{itemize}

\vspace{\baselineskip}

Together, these components (Model, View, Controller, DAO, Service, and DTO) form a cohesive architecture that promotes 
separation of concerns, modularity, maintainability, and testability in software applications. They enable parallel 
development of different components by separate teams, support diverse views of the same data, and ensure efficient data 
transfer across the application.

\vspace{\baselineskip}

\textbf{Locator Pattern}

The Locator design pattern effectively manages dependencies and interactions among modules in software applications.
By allowing clients to request implementations from a locator instead of directly instantiating implementation 
classes, it decouples operations. This approach enhances flexibility and modularity within the application's 
architecture, making it well-suited for integration with the MVC Pattern.

\newpage

\textbf{Singleton Pattern}

The Singleton pattern ensures that a class has a single instance and provides a global point of access to it. It is 
particularly valuable in scenarios where multiple components need consistent access to a shared resource, such as 
database connections, thereby preventing redundant object creation and optimizing resource utilization. Moreover, 
it finds application in classes that manage thread execution, such as \textit{ErrorTaskManager}, 
\textit{AperiodicExecutorTaskServiceImpl}, and \textit{PeriodicExecutorTaskServiceImpl}. This pattern ensures that 
these classes maintain singular control over their respective tasks, enhancing efficiency and coordination within the application.

\subsection*{Techniques}

\textbf{Session Management}

Session management in the application optimizes user state using the HttpSession interface. Storing crucial user information in session variables 
reduces the need for frequent database accesses, thereby enhancing performance and user experience.

\vspace{\baselineskip}

\textbf{Task Abstraction}

The class Task represents individual asynchronous operations within the application. Each task is defined by its priority and timestamp 
and implements the abstract method executeJob to initiate task execution. Various Task implementations manage data redundancy across different 
MongoDB collections and ensure synchronization between MongoDB and Neo4j databases, leveraging Data Access Objects (DAOs) for efficient data management.

\vspace{\baselineskip}

\textbf{Task Manager}

The Task Manager defines methods for managing a task queue capable of handling up to 30 tasks. Tasks are added based on priority 
or timestamp in case of equal priority. The concrete implementation, ErrorTaskManager, specifically manages tasks encountering transient errors during execution.

\vspace{\baselineskip}

Execution of tasks is handled by a dedicated thread, which continuously retrieves and processes tasks from the queue. When the queue is empty, the 
thread waits for new tasks. Tasks encountering RETRYABLE errors during execution are rescheduled in the queue for future retries, ensuring eventual
data consistency across the application. Additionally, tasks failing consecutively five times generate a warning log message to prevent indefinite looping.

\vspace{\baselineskip}

\textbf{Executor Service}

The ExecutorService, implemented through the Java interface, manages two types of tasks: Runnable for asynchronous operations 
without immediate result retrieval, and Callable using the Future type for retrieving data in the main thread upon task completion. 
This concurrency model significantly boosts application efficiency by parallelizing operations.

\vspace{\baselineskip}

Within the application, Runnable tasks manage redundancy and ensure eventual consistency across both MongoDB and 
Neo4j databases, thereby minimizing performance impacts and enhancing application responsiveness. Callable tasks 
are utilized in controllers to handle multiple accesses for retrieving necessary information to load pages efficiently.

\newpage

\section{Description of Main Classes}

\subsection*{Controller}
\renewcommand{\arraystretch}{1.5}
\begin{longtable}{|>{\arraybackslash}p{0.3\linewidth}|>{\arraybackslash}p{0.73\linewidth}|}
    \cline{1-2}
    \textbf{Class} & \textbf{Description} \\
    \cline{1-2}
    AuthServlet & Handles requests on authentication page \\
    \cline{1-2}
    MainPageServlet & Handles requests on the mainPage \\
    \cline{1-2}
    ManagerServlet & Handles business logic for manager \\    
    \cline{1-2}
    MediaContentServlet & handle requests on the media content page and retrieve or set media content releted info \\
    \cline{1-2}
    ProfileServlet & Handles requests on the profile page \\
    \cline{1-2}
    UserServlet & Handles requests related to user model \\
    \cline{1-2}
\end{longtable}

\subsection*{DAO}
\renewcommand{\arraystretch}{1.5}
\begin{longtable}{|>{\raggedright\arraybackslash}p{0.3\linewidth}|>{\raggedright\arraybackslash}p{0.1\linewidth}|>{\raggedright\arraybackslash}p{0.6\linewidth}|}
    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endfirsthead

    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endhead

    \hline
    \endfoot

    \hline
    \endlastfoot

    MediaContentDAO & interfaces & Collection of methods for media content database related entities on mongoDB \\
    \hline
    ReviewDAO B & interfaces & Collection of methods for review database related entities on mongoDB \\
    \hline
    UserDAO & interfaces & Collection of methods for user database related entities on mongoDB \\
    \hline
    AnimeDAOMongoImpl & mongo & Contains all the method implementation for the MongoDB database anime entities \\
    \hline      
    BaseMongoDBDAO & mongo & Contains all the method implementations for the MongoDB database \\
    \hline
    MangaDAOMongoImpl & mongo & Contains all the method implementations for the MongoDB database manga entities \\
    \hline
    ReviewDAOMongoImpl & mongo & Contains all the method implementations for the MongoDB database review entities \\
    \hline
    UserDAOMongoImpl & mongo & Contains all the method implementations for the MongoDB database user entities \\
    \hline
    AnimeDAONeo4jImpl & neo4j & Contains all the method implementation for the Neo4j database anime entities \\
    \hline
    BaseNeo4jDAO & neo4j & Contains all the method implementations for the Neo4j database \\
    \hline
    MangaDAONeo4jImpl & neo4j & Contains all the method implementation for the Neo4j database manga entities \\
    \hline
    UserDAONeo4jImpl & neo4j & Contains all the method implementation for the Neo4j database user entities \\
    \hline
    DAOLocator & & Implements the locator pattern for accessing DAOs based on the specified data repository \\
    \hline
\end{longtable}

\newpage

\subsection*{DTO}
\renewcommand{\arraystretch}{1.5}
\begin{longtable}{|>{\raggedright\arraybackslash}p{0.25\linewidth}|>{\raggedright\arraybackslash}p{0.15\linewidth}|>{\raggedright\arraybackslash}p{0.6\linewidth}|}
    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endfirsthead

    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endhead

    \hline
    \endfoot

    \hline
    \endlastfoot

    AnimeDTO & mediaContent & Represents data transfer object containing attributes for animes \\
    \hline
    MangaDTO & mediaContent & Represents data transfer object containing attributes for mangas \\
    \hline
    MediaContentDTO & interfaces & Defines common attributes for media content \\
    \hline
    DashboardDTO & statistics & Contains statistical data for the dashboard \\
    \hline
    MongoDBStats & statistics & Provides statistics specific to MongoDB \\
    \hline
    LoggedUserDTO & & Holds information about a logged-in user. \\
    \hline
    PageDTO & & Represents pagination details \\
    \hline
    ReviewDTO & & Contains attributes for reviews \\
    \hline
    UserRegistrationDTO & & Holds data for user registration \\
    \hline
    UserSummaryDTO & & Provides a summary of user information \\
    \hline
\end{longtable}


\subsection*{Model}
\renewcommand{\arraystretch}{1.5}
\begin{longtable}{|>{\raggedright\arraybackslash}p{0.25\linewidth}|>{\raggedright\arraybackslash}p{0.15\linewidth}|>{\raggedright\arraybackslash}p{0.6\linewidth}|}
    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endfirsthead

    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endhead

    \hline
    \endfoot

    \hline
    \endlastfoot

    Anime & mediaContent & Provides unique anime attributes by extending parent class MediaContent and related getter and setter methods. \\
    \hline
    Manga & mediaContent & Provides unique manga attributes by extending parent class MediaContent and related getter and setter methods. \\
    \hline
    MangaAuthor & mediaContent & Contains manga author attributes and related getter and setter methods. \\
    \hline
    MediaContent & mediaContent & Contains all the attributes used by types of media contents and their getter and setter methods. \\
    \hline
    Manager & registeredUser & Provides unique manager attributes by extending parent class RegisteredUser and related getter and setter methods. \\
    \hline
    RegisteredUSer & registeredUser & Contains all the attributes used by types of registered users and their getter and setter methods. \\
    \hline
    User & registeredUser & Provides unique user attributes by extending parent class RegisteredUser and related getter and setter methods. \\
    \hline
    Review &  & Contains review attributes and related getter and setter methods. \\
    \hline
\end{longtable}

\newpage

\subsection*{Service}
\renewcommand{\arraystretch}{1.5} % Adjusts the row height
\begin{longtable}{|>{\raggedright\arraybackslash}p{0.3\linewidth}|>{\raggedright\arraybackslash}p{0.2\linewidth}|>{\raggedright\arraybackslash}p{0.5\linewidth}|}
   
    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endfirsthead

    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endhead

    \hline
    \endfoot

    \hline
    \endlastfoot

    CreateMediaTask & impl/ asinc\_media\_tasks & Implementation of methods for media task creation for MediaContentService \\
    \hline
    DeleteMediaTask B & impl/ asinc\_media\_tasks & Implementation of methods for media task deletion for MediaContentService \\
    \hline
    RefreshLatestReviewsTasks & impl/ asinc\_media\_tasks & Implementation of methods for refreshing latest reviews for MediaContentService \\
    \hline
    UpdateAverageRatingTask & impl/ asinc\_media\_tasks & Implementation of methods for updating average rating for MediaContentService \\
    \hline
    UpdateMediaRedundancyTask & impl/ asinc\_media\_tasks & Implementation of methods for updating media redundancy for MediaContentService \\
    \hline
    UpdateMediaTask & impl/ asinc\_media\_tasks & Implementation of methods for updating media for MediaContentService \\
    \hline
    UpdateNumberofLikesTask & impl/ asinc\_media\_tasks & Implementation of methods for updating numbers of likes for MediaContentService \\
    \hline
    RemoveDeletedMedia ReviewsTask & impl/ asinc\_review\_tasks & Implementation of methods for removing reviews of deleted media for ReviewService \\
    \hline
    RemoveDeletedUser ReviewsTask & impl/ asinc\_review\_tasks & Implementation of methods for removing reviews of deleted user for ReviewService \\
    \hline
    UpdateReviewRedundancyTask & impl/ asinc\_review\_tasks & Implementation of methods for updating review redundancy for ReviewService \\
    \hline
    CreateUserTask & impl/ asinc\_user\_tasks & Implementation of methods for user creation for UserService \\
    \hline
    DeleteUserTask & impl/ asinc\_user\_tasks & Implementation of methods for user deletion for UserService \\
    \hline
    UpdateNumberOfFollowedTask B & impl/ asinc\_user\_tasks & Implementation of methods for updating number of followed for UserService \\
    \hline
    UpdateNumberOfFollowersTask & impl/ asinc\_user\_tasks & Implementation of methods for updating number of followers for UserService \\
    \hline
    UpdateUserTask & impl/ asinc\_user\_tasks & Implementation of methods for updating user for MediaContentService \\
    \hline
    AperiodicExecutor TaskServiceImpl & impl & Implementation of aperiodic tasks for ExecutorTaskService \\
    \hline
    ErrorTaskManager & impl & Implementation of TaskManager interface to handle error \\
    \hline
    MediaContentServiceImpl & impl & Implementation of MediaContentService, providing media content operations \\
    \hline
    PeriodicExecutor TaskServiceImpl & impl & Implementation of periodic tasks for ExecutorTaskService \\
    \hline
    ReviewServiceImpl & impl & Implementation of ReviewService, providing review operations \\
    \hline
    UserServiceImpl & impl & Implementation of UserService, providing user operations \\
    \hline
    ExecutorTaskService & interfaces & Collection of methods for task management \\
    \hline
    MediaContentService & interfaces & Collection of methods for media content service \\
    \hline
    ReviewService & interfaces & Collection of methods for review service \\
    \hline
    Task & interfaces & Collection of methods for execution operations \\
    \hline
    TaskManager & interfaces & Collection of methods for managing task prioritization \\
    \hline
    UserService & interfaces & Collection of methods for user service \\
    \hline
    ServiceLocator & & Implements locator pattern for services \\
    \hline
\end{longtable}

\section {MongoDB queries}
Some of the most important MongoDB queries for analytic and suggestion purposes. 

\subsection*{USER:}
\textbf{Get Distribution}\\
GetDistribution query to get the user's location, birthday year that gave the highest rating to the application
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public Map<String, Integer> getDistribution(String criteria) throws DAOException {
    try {
        MongoCollection<Document> usersCollection = getCollection(COLLECTION_NAME);

        List<Bson> pipeline = new ArrayList<>();
        if (criteria.equals("birthday") || criteria.equals("joined_on")) {
            pipeline.addAll(List.of(
                    match(exists(criteria)),
                    project(fields(computed("year", new Document("$year", "$" + criteria)), include("app_rating" ))),
                    group("$year", sum("count", 1)),
                    sort(descending("count"))));
        } else if (criteria.equals("location") || criteria.equals("gender")) {
            pipeline.addAll(List.of(
                    match(exists(criteria)),
                    project(fields(include(criteria, "app_rating"))),
                    group("$" + criteria, sum("count", 1)),
                    sort(descending("count"))));
        } else {
            throw new Exception("UserDAOMongoImpl: getDistribution: Invalid criteria");
        }

        List<Document> aggregationResult = usersCollection.aggregate(pipeline).into(new ArrayList<>());
        if (aggregationResult.isEmpty()) {
            throw new MongoException("UserDAOMongoImpl: getDistribution: No data found");
        }

        Map<String,Integer> map = new LinkedHashMap<>();
        for (Document doc : aggregationResult) {
            if (criteria.equals("birthday") || criteria.equals("joined_on")) {
                map.put(String.valueOf(doc.getInteger("_id")), doc.getInteger("count"));
            } else {
                map.put(doc.getString("_id"), doc.getInteger("count"));
            }
        }
        return map;

    } catch (MongoException e){
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());
    } catch (Exception e){
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}

\begin{itemize}
    \item Mongo Shell Query:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
    db.collection.aggregate([
        {
            // Match stage to filter documents where 'criteriaOfSearch' exists
            $match: {
                [criteriaOfSearch]: { $exists: true }
            }
        },
        // Project stage to include 'criteriaOfSearch' and 'app_rating' fields
        {
            $project: {
                [criteriaOfSearch]: 1,
                app_rating: 1
            }
        },
        // Group stage to count occurrences of each 'criteriaOfSearch'
        {
            $group: {
                _id: "$" + criteriaOfSearch,
                count: { $sum: 1 }
            }
        },
        // Sort stage to sort documents by 'count' in descending order
        {
            $sort: {
                count: -1
            }
        }
    ]);     


\end{lstlisting} 
\textbf{Average App Rating}\\
Calculates the average application rating based on the specified search criteria
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
    public Map<String, Double> averageAppRating(String criteria) throws DAOException {
    try {
        MongoCollection<Document> usersCollection = getCollection(COLLECTION_NAME);

        List<Bson> pipeline = List.of(
                match(and(exists(criteria), exists("app_rating"))),
                group("$" + criteria, avg("averageAppRating", "$app_rating")),
                sort(descending("averageAppRating"))
        );

        List<Document> aggregationResult = usersCollection.aggregate(pipeline).into(new ArrayList<>());
        if (aggregationResult.isEmpty()) {
            throw new MongoException("UserDAOMongoImpl: averageAppRating: No data found");
        }

        Map<String,Double> map = new LinkedHashMap<>();
        for (Document doc : aggregationResult) {
            map.put(doc.getString("_id"), doc.getDouble("averageAppRating"));
        }
        return map;

    } catch (MongoException e){
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());
    }
    catch (Exception e){
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
        
    \begin{itemize}
        \item Mongo Shell Query:
    \end{itemize}
    \begin{lstlisting}[language=JavaScript]
db.getCollection.aggregate([
    { 
        // Match stage: Filters documents to include only those that 
        // have both the specified 'criteria' field and 'app_rating' field.
        $match: { 
                $and: [
                { [criteria]: { $exists: true } },
                { app_rating: { $exists: true } }
            ]
        } 
    },
    { 
        // Group stage: Groups the filtered documents by the 'criteria' field.
        // Calculates the average value of 'app_rating' for each group.
        $group: { 
            _id: "$" + criteria, 
            averageAppRating: { $avg: "$app_rating" }
        } 
    },
    { 
        // Sort stage: Sorts the groups in descending order by 'averageAppRating'.
        $sort: { 
            averageAppRating: -1 
        } 
    }
]).toArray();      
        
\end{lstlisting}
\textbf{Average App Rating By Age}\\
Calculates the average app rating for users grouped by age ranges.
The age ranges are defined as follows:\\
- 0-13 years\\
- 13-20 years\\
- 20-30 years\\
- 30-40 years\\
- 40-50 years\\
- 50+ years
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public Map<String, Double> averageAppRatingByAgeRange() throws DAOException {
    try {
        MongoCollection<Document> usersCollection = getCollection(COLLECTION_NAME);

        // Define the boundaries for the age ranges and the output fields
        List<Long> boundaries = Arrays.asList(0L, 13L, 20L, 30L, 40L, 50L);
        BsonField[] outputFields = {
                new BsonField("avg_app_rating", new Document("$avg", "$app_rating"))
        };
        BucketOptions options = new BucketOptions()
                .defaultBucket(50L)
                .output(outputFields);

        List<Bson> pipeline = List.of(
                match(and(exists("birthday"), exists("app_rating"))),
                project(fields(
                        computed("age", new Document("$floor", new Document("$divide",
                        Arrays.asList(
                                new Document("$subtract", Arrays.asList(new Date(), "$birthday")),
                                1000L * 60 * 60 * 24 * 365
                        )))),
                        include("app_rating")
                )),
                bucket("$age", boundaries, options)
        );

        List<Document> aggregationResult = usersCollection.aggregate(pipeline).into(new ArrayList<>());

        if (aggregationResult.isEmpty()) {
            throw new MongoException("UserDAOMongoImpl: averageAppRatingByAgeRange: No data found");
        }

        Map<String, Double> map = new LinkedHashMap<>();
        for (Document doc : aggregationResult) {
            String ageRange = convertIntegerToAgeRange(doc.getLong("_id"));
            map.put(ageRange, doc.getDouble("avg_app_rating"));
        }

        return map;

    } catch (MongoException e){
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());
    } catch (Exception e){
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
    
\begin{itemize}
    \item Mongo Shell Query:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
db.getCollection('COLLECTION_NAME').aggregate([
    { 
        // Match stage: Filters documents to include only those that 
        // have both the 'birthday' field and 'app_rating' field.
        $match: { 
            $and: [
                { birthday: { $exists: true } }, 
                { app_rating: { $exists: true } }
            ]
        } 
    },
    { 
        // Project stage: Adds a new field 'age' calculated by subtracting 
        // the 'birthday' from the current date, converting the difference 
        // from milliseconds to years, and taking the floor of the result.
        // Also includes the 'app_rating' field.
        $project: { 
            age: { 
                $floor: { 
                    $divide: [
                        { $subtract: [ new Date(), "$birthday" ] },
                        1000 * 60 * 60 * 24 * 365
                    ]
                }
            },
            app_rating: 1 
        } 
    },
    { 
        // Bucket stage: Groups the documents into buckets based on the 'age' field.
        // Specifies boundaries for the buckets and assigns documents with an age 
        // outside these boundaries to the default bucket (50+ years).
        // For each bucket, calculates the average value of 'app_rating'.
        $bucket: {
            groupBy: "$age",
            boundaries: [0, 13, 20, 30, 40, 50],
            default: 50,
            output: { 
                avg_app_rating: { $avg: "$app_rating" }
            }
        }
    }
]).toArray();
       
    
\end{lstlisting}





\subsection*{REVIEW:}
\textbf{Get Media Content Rating By Year}\\
Retrieves the average ratings for a specific media content (anime or manga) by year within a specified range.
The aggregation pipeline performs the following steps:\\
1. Matches the reviews for the specified media content ID and date range, ensuring the reviews have a rating.\\
2. Groups the reviews by year and calculates the average rating for each year.\\
3. Projects the results to include the year and the calculated average rating.\\
4. Sorts the results by year in ascending order.
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public Map<String, Double> getMediaContentRatingByYear(MediaContentType type, String mediaContentId, int startYear, int endYear) throws  DAOException {
    try  {
        // Get media content rating by year
        MongoCollection<Document> reviewCollection = getCollection(COLLECTION_NAME);

        String nodeType = type.equals(MediaContentType.ANIME) ? "anime" : "manga";
        Date startDate = ConverterUtils.localDateToDate(LocalDate.of(startYear, 1, 1));
        Date endDate = ConverterUtils.localDateToDate(LocalDate.of(endYear + 1, 1, 1));
        List<Bson> pipeline = List.of(
                match(and(
                        eq(nodeType + ".id", new ObjectId(mediaContentId)),
                        exists("rating", true),
                        gte("date", startDate),
                        lt("date", endDate)
                )),
                group(new Document("$year", "$date"), avg("average_rating", "$rating")),
                project(fields(
                        excludeId(),
                        computed("year", "$_id"),
                        include("average_rating"))
                ),
                sort(ascending("year"))
        );
        List<Document> result = reviewCollection.aggregate(pipeline).into(new ArrayList<>());

        // Initialize the result map with years and default values
        Map<String, Double> resultMap = new LinkedHashMap<>();
        for (int year = startYear; year <= endYear; year++) {
            resultMap.put(String.valueOf(year), null);
        }

        // Populate the result map with the average ratings
        for (Document document : result) {
            Double averageRating = document.getDouble("average_rating");
            Integer year = document.getInteger("year");
            resultMap.put(String.valueOf(year), averageRating);
        }
        return resultMap;

    } catch (MongoException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());
    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
    
\begin{itemize}
    \item Mongo Shell Query:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
// Match stage to filter documents based on specified conditions
db.collection.aggregate([
    {
        // Filters documents to include only those where:
        // 1. The nested 'id' field under 'nodeType' matches the specified 'mediaContentId'.
        // 2. The 'rating' field exists.
        // 3. The 'date' field is within the specified date range (startDate to endDate).
        $match: {
            [`${nodeType}.id`]: new ObjectId(mediaContentId),
            rating: { $exists: true },
            date: { $gte: startDate, $lt: endDate }
        }
    },
    {
        // Groups the filtered documents by year extracted from the 'date' field.
        // Calculates the average value of 'rating' for each year.
        $group: {
            _id: { $year: "$date" },
            average_rating: { $avg: "$rating" }
        }
    },
    {
        // Projects the result to include the 'year' and 'average_rating' fields,
        // excluding the '_id' field.
        $project: {
            _id: 0,
            year: "$_id",
            average_rating: 1
        }
    },
    {
        // Sort stage to sort documents by year in ascending order
        $sort: { year: 1 }
    }
]);
\end{lstlisting}
\textbf{Get Media Content Rating By Month}\\
Retrieves the average ratings for a specific media content (anime or manga) by month for a specified year.
The aggregation pipeline performs the following steps:\\
1. Matches the reviews for the specified media content ID and year, ensuring the reviews have a rating.\\
2. Groups the reviews by month and calculates the average rating for each month.\\
3. Projects the results to include the month and the calculated average rating.\\
4. Sorts the results by month in ascending order.
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public Map<String, Double> getMediaContentRatingByMonth(MediaContentType type, String mediaContentId, int year) throws DAOException {
    try  {
        // Get media content rating by month
        MongoCollection<Document> reviewCollection = getCollection(COLLECTION_NAME);

        String nodeType = type.equals(MediaContentType.ANIME) ? "anime" : "manga";
        Date startDate = ConverterUtils.localDateToDate(LocalDate.of(year, 1, 1));
        Date endDate = ConverterUtils.localDateToDate(LocalDate.of(year + 1, 1, 1));
        List<Bson> pipeline = List.of(
                match(and(
                        eq(nodeType + ".id", new ObjectId(mediaContentId)),
                        exists("rating", true),
                        gte("date", startDate),
                        lt("date", endDate)
                )),
                group(new Document("$month", "$date"),
                        avg("average_rating", "$rating")
                ),
                project(fields(
                        excludeId(),
                        computed("month", "$_id"),
                        include("average_rating")
                )),
                sort(ascending("month"))
        );
        List<Document> result = reviewCollection.aggregate(pipeline).into(new ArrayList<>());

        // Initialize the result map with months and default values
        Map<String, Double> resultMap = new LinkedHashMap<>();
        for (Month month : Month.values()) {
            resultMap.put(month.getDisplayName(TextStyle.FULL, Locale.ENGLISH), null);
        }

        // Populate the result map with the average ratings
        for (Document document : result) {
            Object ratingObj = document.get("average_rating");
            Double averageRating = ratingObj instanceof Integer ratingInt ? ratingInt.doubleValue() : (Double) ratingObj;
            Integer month = document.getInteger("month");
            resultMap.put(Month.of(month).getDisplayName(TextStyle.FULL, Locale.ENGLISH), averageRating);
        }
        return resultMap;

    } catch (MongoException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());
    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Mongo Shell Query:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
db.getCollection.aggregate([
    { 
        // Match stage: Filters documents to include only those that meet the specified conditions.
        $match: { 
            $and: [
                // Includes documents where the nested 'id' field under 'nodeType' matches 'mediaContentId'.
                { [nodeType + ".id"]: mediaContentId },
                // Includes documents where the 'rating' field exists.
                { rating: { $exists: true } },
                // Includes documents where the 'date' field is greater than or equal to 'startDate'.
                { date: { $gte: startDate } },
                // Includes documents where the 'date' field is less than 'endDate'.
                { date: { $lt: endDate } }
            ]
        } 
    },
    { 
        // Group stage: Groups the filtered documents by the month extracted from the 'date' field.
        // Calculates the average value of 'rating' for each month.
        $group: { 
            _id: { $month: "$date" },
            average_rating: { $avg: "$rating" }
        } 
    },
    { 
        // Project stage: Shapes the output documents to include 'month' and 'average_rating' fields.
        // Excludes the '_id' field.
        $project: { 
            _id: 0,
            month: "$_id",
            average_rating: 1
        } 
    },
    { 
        // Sort stage: Sorts the documents by 'month' in ascending order.
        $sort: { 
            month: 1 
        } 
    }
]).toArray();
\end{lstlisting}
\textbf{Suggest Media Content}\\
Suggests media content (anime or manga) based on user criteria (location or birthday year).
The aggregation pipeline performs the following steps:\\
1. Matches the reviews with a rating, the specified media content type and the user criteria.\\
2. Groups the reviews by media content ID and calculates the average rating for each media content.\\
3. Projects the results to include the media content title and the calculated average rating.\\
4. Sorts the results by average rating in descending order.\\
5. Limits the results to 20 entries.
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public List<MediaContentDTO> suggestMediaContent(MediaContentType mediaContentType, String criteriaType, String criteriaValue) throws DAOException {
    try  {
        // Suggest media content based on user criteria
        MongoCollection<Document> reviewCollection = getCollection(COLLECTION_NAME);
        String nodeType = mediaContentType.equals(MediaContentType.ANIME) ? "anime" : "manga";

        Bson filter = and(
                exists("rating", true),
                exists(nodeType, true)
        );

        if (criteriaType.equals("location")) {
            filter = and(filter, eq("user.location", criteriaValue));
        } else if (criteriaType.equals("birthday")) {
            Date startDate = ConverterUtils.localDateToDate(LocalDate.of(Integer.parseInt(criteriaValue), 1, 1));
            Date endDate = ConverterUtils.localDateToDate(LocalDate.of(Integer.parseInt(criteriaValue) + 1, 1, 1));
            filter = and(filter, gte("user.birthday", startDate), lt("user.birthday", endDate));
        } else {
            throw new Exception("ReviewDAOMongoImpl: suggestMediaContent: Invalid criteria type");
        }

        List<Bson> pipeline = new ArrayList<>(List.of(
                match(filter),
                group("$" + nodeType + ".id",
                        first("title", "$" + nodeType + ".title"),
                        avg("average_rating", "$rating")),
                sort(descending("average_rating")),
                project(include("title")),
                limit(20)));

        List<Document> result = reviewCollection.aggregate(pipeline).into(new ArrayList<>());
        if (result.isEmpty()) {
            throw new MongoException("ReviewDAOMongoImpl: suggestMediaContent: No reviews found");
        }

        List<MediaContentDTO> entries = new ArrayList<>();
        for (Document document : result) {
            String contentId = String.valueOf(document.getObjectId("_id"));
            String title = document.getString("title");

            MediaContentDTO mediaContentDTO;
            if (nodeType.equals("anime")) {
                mediaContentDTO = new AnimeDTO(contentId, title);
            } else {
                mediaContentDTO = new MangaDTO(contentId, title);
            }
            entries.add(mediaContentDTO);
        }
        return entries;

    } catch (MongoException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());
    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Mongo Shell Query:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
db.collection.aggregate([
    {
        // Match documents based on a dynamic user criteria
        // It dynamically matches documents where a field in the 'user' object 
        // (specified by 'criteriaType') has the value 'criteriaValue'.
        $match: {
        ["user." + criteriaType]: criteriaValue
        }
    },
    {
        // Group stage: Groups documents by the node type's ID.
        // For each group, it retrieves the first title and calculates the average rating.
        $group: {
        _id: "$" + nodeType + ".id", // Group by the node type's ID
        title: { $first: "$" + nodeType + ".title" }, // Get the first title in the group
        average_rating: { $avg: "$rating" } // Calculate the average rating for the group
        }
    },
    {
        // Sort stage: Sorts the grouped documents by average rating in descending order.
        $sort: { average_rating: -1 }
    },
    {
        // Limit stage: Limits the number of results to a constant defined by 'Constants.PAGE_SIZE'.
        $limit: Constants.PAGE_SIZE
    }
    ]);
\end{lstlisting}


\subsection*{MANGA/ANIME:}
\textbf{Get Best Criteria}\\
Retrieves the best criteria based on the average rating of the Anime objects in the MongoDB database.
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public Map<String, Double> getBestCriteria (String criteria, boolean isArray, int page) throws DAOException {
    try {
        MongoCollection<Document> animeCollection = getCollection(COLLECTION_NAME);
        int pageOffset = (page - 1) * Constants.PAGE_SIZE;

        List<Bson> pipeline;
        if (isArray) {
            pipeline = List.of(
                    match(and(exists(criteria), ne("average_rating", null))),
                    unwind("$" + criteria),
                    group("$" + criteria, avg("criteria_average_rating", "$average_rating")),
                    sort(descending("criteria_average_rating")),
                    skip(pageOffset),
                    limit(25)
            );
        } else {
            pipeline = List.of(
                    match(Filters.exists(criteria)),
                    group("$" + criteria, avg("criteria_average_rating", "$average_rating")),
                    sort(new Document("criteria_average_rating", -1)),
                    skip(pageOffset),
                    limit(25)
            );
        }

        List <Document> document = animeCollection.aggregate(pipeline).into(new ArrayList<>());
        Map<String, Double> bestCriteria = new LinkedHashMap<>();
        for (Document doc : document) {
            Double avgRating = doc.get("criteria_average_rating") instanceof Integer?
                    doc.getInteger("criteria_average_rating").doubleValue() :
                    doc.getDouble("criteria_average_rating");
            bestCriteria.put(doc.get("_id").toString(), avgRating);
        }

        return bestCriteria;

    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Mongo Shell Query:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
db.collection.aggregate([
    // Match stage to filter documents where 'criteria' exists and 'average_rating' is not null
    {
        $match: {
            criteria: { $exists: true },
            average_rating: { $ne: null }
        }
    },
    // Unwind stage to deconstruct the 'criteria' array field
    {
        $unwind: "$" + criteria
    },
    // Group stage to calculate the average rating for each criteria
    {
        $group: {
            // Group by each individual 'criteria' element
            _id: "$" + criteria,
            // Calculate the average rating for each 'criteria'
            criteria_average_rating: { $avg: "$average_rating" }
        }
    },
    // Sort stage to sort documents by 'criteria_average_rating' in descending order
    {
        $sort: {
            criteria_average_rating: -1
        }
    },
    // Skip stage to skip the first 'pageOffset' documents
    {
        $skip: pageOffset
    },
    // Limit stage to limit the results to 25 documents
    {
        $limit: 25
    }
]);
\end{lstlisting}




\newpage


  
\section{GraphDB queries}
Some of the most important Neo4j queries for analytic and suggestion purposes.
\subsection*{USERS:}
\textbf{Suggest User By Common Likes}\\
Retrieves a list of suggested users for a specific user based on common likes from the Neo4j database.
The method performs the following steps:\\
1. Retrieve users who like the same media content as the specified user in the last 6 month.\\
2. Retrieve users who like the same media content as the specified user in the last year.\\
3. Retrieve users who like the same media content as the specified user.\\
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public List<UserSummaryDTO> suggestUsersByCommonLikes(String userId, Integer limit, MediaContentType type) throws DAOException {

    try (Session session = getSession()) {
        if (type == null) {
            throw new IllegalArgumentException("Media content type must be specified");
        }

        int n = limit == null ? 5 : limit;
        int remaining;

        StringBuilder queryBuilder = new StringBuilder();
        if (type == MediaContentType.ANIME)
            queryBuilder.append("MATCH (u:User {id: $userId})-[r:LIKE]->(media:Anime)<-[:LIKE]-(suggested:User) ");
        else
            queryBuilder.append("MATCH (u:User {id: $userId})-[r:LIKE]->(media:Manga)<-[:LIKE]-(suggested:User) ");
        queryBuilder.append("""
                WHERE u <> suggested AND r.date >= date($date)
                WITH suggested, COUNT(DISTINCT media) AS commonLikes
                WHERE commonLikes > $min
                RETURN suggested AS user, commonLikes
                ORDER BY commonLikes DESC
                LIMIT $n
                """);
        String query1 = queryBuilder.toString();
        Value params1 = parameters("userId", userId, "n", n, "date", LocalDate.now().minusMonths(6), "min", 5);

        List<UserSummaryDTO> suggested = session.executeRead(
                tx -> tx.run(query1, params1).list()
        ).stream()
                .map(this::recordToUserSummaryDTO)
                .collect(Collectors.toList());

        remaining = n - suggested.size();

        if (remaining > 0) {
            Value params2 = parameters("userId", userId, "n", n, "date", LocalDate.now().minusYears(1), "min", 5);

            List<Record> records = session.executeRead(tx -> tx.run(query1, params2).list());
            for (Record record : records) {
                UserSummaryDTO userDTO = recordToUserSummaryDTO(record);
                if (!suggested.contains(userDTO))
                    suggested.add(userDTO);
                if (suggested.size() == n)
                    break;
            }

            remaining = n - suggested.size();
        }

        if(remaining > 0) {
            StringBuilder queryBuilder3 = new StringBuilder();
            if (type == MediaContentType.ANIME)
                queryBuilder3.append("MATCH (u:User {id: $userId})-[r:LIKE]->(media:Anime)<-[:LIKE]-(suggested:User) ");
            else
                queryBuilder3.append("MATCH (u:User {id: $userId})-[r:LIKE]->(media:Manga)<-[:LIKE]-(suggested:User) ");
            queryBuilder3.append("""
                    WHERE u <> suggested
                    WITH suggested, COUNT(DISTINCT media) AS commonLikes
                    RETURN suggested AS user, commonLikes
                    ORDER BY commonLikes DESC
                    LIMIT $n
                    """);
            String query2 = queryBuilder3.toString();
            Value params3 = parameters("userId", userId, "n", n);

            List<Record> records = session.executeRead(tx -> tx.run(query2, params3).list());
            for (Record record : records) {
                UserSummaryDTO userDTO = recordToUserSummaryDTO(record);
                if (!suggested.contains(userDTO))
                    suggested.add(userDTO);
                if (suggested.size() == n)
                    break;
            }
        }

        return suggested.isEmpty() ? null : suggested;

    } catch (Neo4jException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());

    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Neo4j Query:
\end{itemize}
\begin{lstlisting}[language=Cypher]
// Match the user with the given userId who has liked media of type Manga
MATCH (u:User {id: $userId})-[r:LIKE]->(media:Manga)<-[:LIKE]-(suggested:User) 
// Filter out the original user from the suggested users and only consider likes after the specified date
WHERE u <> suggested AND r.date >= $date
// Pass the suggested users and count of distinct media liked by both users to the next stage
WITH suggested, COUNT(DISTINCT media) AS commonLikes
// Filter out users with common likes less than or equal to the minimum threshold
WHERE commonLikes > $min
// Return the suggested users and the count of common likes
RETURN suggested AS user, commonLikes
// Order the results by the count of common likes in descending order
ORDER BY commonLikes DESC
// Limit the number of results to the specified maximum
LIMIT $n
\end{lstlisting}
\textbf{Suggest Users By Common Followings}\\
Retrieves a list of suggested users for a specific user based on common followings from the Neo4j database.
The method performs the following steps:\\
1. Retrieve users that follow user's followings and have more than 5 common followings.\\
2. Retrieve users that are followed by user's followings and have more than 5 connections.\\
3. Retrieve users that follow user's followings.\\
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public List<UserSummaryDTO> suggestUsersByCommonFollowings(String userId, Integer limit) throws DAOException {
    try (Session session = getSession()) {
        int n = limit == null ? 5 : limit;
        int remaining;

        // suggest users that follow user's followings and have more than 5 common followings
        String query = """
                MATCH (u:User {id: $userId})-[:FOLLOWS]->(following:User)<-[:FOLLOWS]-(suggested:User)
                WHERE NOT (u)-[:FOLLOWS]->(suggested) AND u <> suggested
                WITH suggested, COUNT(DISTINCT following) AS commonFollowings
                WHERE commonFollowings > 5
                RETURN suggested as user
                ORDER BY commonFollowings DESC
                LIMIT $n
                """;
        Value params = parameters("userId", userId, "n", n);

        List<UserSummaryDTO> suggested = session.executeRead(
                tx -> tx.run(query, params).list()
        ).stream()
                .map(this::recordToUserSummaryDTO)
                .collect(Collectors.toList());

        remaining = n - suggested.size();

        // if there are not enough suggestions, suggest users that are followed by the user's followings and have more than 5 connections
        if (remaining > 0) {
            String query2 = """
                    MATCH (u:User {id: $userId})-[:FOLLOWS]->(following:User)-[:FOLLOWS]->(suggested:User)
                    WHERE NOT (u)-[:FOLLOWS]->(suggested) AND u <> suggested
                    WITH suggested, COUNT(DISTINCT following) AS commonUsers
                    WHERE commonUsers > 5
                    RETURN suggested as user
                    ORDER BY commonUsers DESC
                    LIMIT $n
                    """;
            Value params2 = parameters("userId", userId, "n", n);

            List<Record> records = session.executeRead(tx -> tx.run(query2, params2).list());
            for (Record record : records) {
                UserSummaryDTO userDTO = recordToUserSummaryDTO(record);
                if (!suggested.contains(userDTO))
                    suggested.add(userDTO);
                if (suggested.size() == n)
                    break;
            }

            remaining = n - suggested.size();
        }

        // if there are still not enough suggestions, suggest users that follow the user's followings
        if (remaining > 0) {
            String query3 = """
                    MATCH (u:User {id: $userId})-[:FOLLOWS]->(following:User)<-[:FOLLOWS]-(suggested:User)
                    WHERE NOT (u)-[:FOLLOWS]->(suggested) AND u <> suggested
                    WITH suggested, COUNT(DISTINCT following) AS commonFollowings
                    RETURN suggested as user
                    ORDER BY commonFollowings DESC
                    LIMIT $n
                    """;
            Value params3 = parameters("userId", userId, "n", n);

            List<Record> records = session.executeRead(tx -> tx.run(query3, params3).list());
            for (Record record : records) {
                UserSummaryDTO userDTO = recordToUserSummaryDTO(record);
                if (!suggested.contains(userDTO))
                    suggested.add(userDTO);
                if (suggested.size() == n)
                    break;
            }
        }

        return suggested.isEmpty() ? null : suggested;

    } catch (Neo4jException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());

    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Neo4j Query:
\end{itemize}
\begin{lstlisting}[language=Cypher]
// Match the user with the given userId who follows other users
MATCH (u:User {id: $userId})-[:FOLLOWS]->(following:User)<-[:FOLLOWS]-(suggested:User) 
// Ensure that the suggested user is not already followed by the original user and they are not the same user
WHERE NOT (u)-[:FOLLOWS]->(suggested) AND u <> suggested 
// Calculate the count of distinct users that both the original user and suggested user follow
WITH suggested, COUNT(DISTINCT following) AS commonFollowers 
// Filter out suggested users who have less than or equal to 5 common followers
WHERE commonFollowers > 5 
// Return the suggested users along with the count of common followers
RETURN suggested as user, commonFollowers 
// Order the results by the count of common followers in descending order
ORDER BY commonFollowers DESC 
// Limit the number of results to the specified maximum
LIMIT $n
\end{lstlisting}


\subsection*{ANIME/MANGA:}
\textbf{Get Trend Media Content By Year}\\
Retrieves a list of trending MangaDTO objects for a specific year from the Neo4j database.
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public Map<MediaContentDTO, Integer> getTrendMediaContentByYear(int year, Integer limit) throws DAOException {
    int n = limit == null ? 5 : limit;
    try (Session session = getSession()) {
        LocalDate startDate = LocalDate.of(year, 1, 1);
        LocalDate endDate = LocalDate.of(year + 1, 1, 1);

        String query = """
        MATCH (m:Manga)<-[r:LIKE]-(u:User)
        WHERE r.date >= date($startDate) AND r.date < date($endDate)
        WITH m, count(r) AS numLikes
        ORDER BY numLikes DESC
        RETURN m AS manga, numLikes
        LIMIT $n
        """;

        Value params = parameters("startDate", startDate, "endDate", endDate, "n", n);

        Map<MediaContentDTO, Integer> result = new LinkedHashMap<>();
        session.executeRead(
                tx -> tx.run(query, params).list()
        ).forEach(record -> {
            MangaDTO mangaDTO = (MangaDTO) recordToMediaContentDTO(record);
            Integer likes = record.get("numLikes").asInt();
            result.put(mangaDTO, likes);
        });

        return result;

    } catch (Neo4jException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());

    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Neo4j Query:
\end{itemize}
\begin{lstlisting}[language=Cypher]
// Match Anime nodes that are liked by Users, with a LIKE relationship and a date constraint
MATCH (a:Anime)<-[r:LIKE]-(u:User)
WHERE r.date >= $startDate AND r.date < $endDate
// Aggregate the results to count the number of likes for each Anime node
WITH a, count(r) AS numLikes
// Order the Anime nodes by the number of likes in descending order
ORDER BY numLikes DESC
// Return the Anime node and the number of likes, limiting the results to the specified maximum
RETURN a AS anime, numLikes
LIMIT $n    
\end{lstlisting}
\textbf{Get Media Content Trend By Likes}\\
Retrieves a list of trending MangaDTO objects by likes from the Neo4j database.
The method performs the following steps:\\
1. Retrieve the trending Manga by likes in the last 6 months.\\
2. If there are not enough trending Manga, retrieve more results from the last year.\\
3. If there are still not enough trending Manga, retrieve more results from the last 5 years.\\
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public List<MediaContentDTO> getMediaContentTrendByLikes(Integer limit) throws DAOException {
    try (Session session = getSession()) {
        int n = limit == null ? 5 : limit;
        int remaining;
        LocalDate now = LocalDate.now();

        // Try to get trending content based on likes in the last 6 months
        String query1 = """
            MATCH (u:User)-[r:LIKE]->(m:Manga)
            WHERE r.date >= date($startDate)
            WITH m, COUNT(r) AS numLikes
            WHERE numLikes > 10
            RETURN m AS manga, numLikes
            ORDER BY numLikes DESC, m.title ASC
            LIMIT $n
            """;

        Value params1 = parameters("startDate", now.minusMonths(6), "n", n);
        List<MediaContentDTO> trendingContent = session.executeRead(
                        tx -> tx.run(query1, params1).list()
                ).stream()
                .map(record -> (MangaDTO) recordToMediaContentDTO(record))
                .collect(Collectors.toList());

        remaining = n - trendingContent.size();

        // If not enough results, add more results from the last year
        if (remaining > 0) {
            Value params2 = parameters("startDate", now.minusYears(1), "n", remaining);

            List<Record> records = session.executeRead(tx -> tx.run(query1, params2).list());
            for (Record record : records) {
                MangaDTO mangaDTO = (MangaDTO) recordToMediaContentDTO(record);
                if (!trendingContent.contains(mangaDTO))
                    trendingContent.add(mangaDTO);
                if (trendingContent.size() == n)
                    break;
            }

            remaining = n - trendingContent.size();
        }

        // If still not enough results, add more results from the last 5 years
        if (remaining > 0) {
            String query2 = """
            MATCH (u:User)-[r:LIKE]->(m:Manga)
            WHERE r.date >= date($startDate)
            WITH m, COUNT(r) AS numLikes
            RETURN m AS manga, numLikes
            ORDER BY numLikes DESC, m.title ASC
            LIMIT $n
            """;
            Value params3 = parameters("startDate", now.minusYears(5), "n", remaining);

            List<Record> records = session.executeRead(tx -> tx.run(query2, params3).list());
            for (Record record : records) {
                MangaDTO mangaDTO = (MangaDTO) recordToMediaContentDTO(record);
                if (!trendingContent.contains(mangaDTO))
                    trendingContent.add(mangaDTO);
                if (trendingContent.size() == n)
                    break;
            }
        }

        return trendingContent.isEmpty() ? null : trendingContent;

    } catch (Neo4jException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());

    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Neo4j Query:
\end{itemize}
\begin{lstlisting}[language=Cypher]
// Match User nodes who have liked Anime nodes with a LIKE relationship and date constraint
MATCH (u:User)-[r:LIKE]->(a:Anime)
WHERE r.date >= $startDate
// Aggregate the results to count the number of LIKE relationships for each Anime node
WITH a, COUNT(r) AS numLikes
// Order the Anime nodes by the number of likes in descending order
ORDER BY numLikes DESC
// Return the Anime node and the number of likes, limiting the results to the specified maximum
RETURN a AS anime, numLikes
LIMIT $n
\end{lstlisting}
\textbf{Get Suggested By Followings}\\
Retrieves a list of suggested MangaDTO objects for a user from the Neo4j database.
The method performs the following steps:\\
1. Retrieve Manga that the user's followings have liked in the last 6 months.\\
2. If there are not enough suggestions, retrieve Manga that the user's followings have liked in the last 2 years.\\
3. If there are still not enough suggestions, retrieve Manga that the user's followings have liked.
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public List<MediaContentDTO> getSuggestedByFollowings(String userId, Integer limit) throws DAOException {
    try (Session session = getSession()) {
        int n = limit == null ? 5 : limit;
        int remaining;
        LocalDate now = LocalDate.now();

        // try to get suggestions based on likes in the last 6 months
        String query1 = """
            MATCH (u:User {id: $userId})-[:FOLLOWS]->(f:User)-[r:LIKE]->(m:Manga)
            WHERE NOT (u)-[:LIKE]->(m) AND r.date >= date($startDate)
            WITH m, COUNT(DISTINCT f) AS num_likes
            RETURN m AS manga
            ORDER BY num_likes DESC, m.title ASC
            LIMIT $n
            """;
        Value params1 = parameters("userId", userId, "n", n, "startDate", now.minusMonths(6));

        List<MediaContentDTO> suggested = session.executeRead(
                        tx -> tx.run(query1, params1).list()
                ).stream()
                .map(record -> (MangaDTO) recordToMediaContentDTO(record))
                .collect(Collectors.toList());

        remaining = n - suggested.size();

        // if there are not enough suggestions, add more results from the last 2 years
        if (remaining > 0) {
            Value params2 = parameters("userId", userId, "n", n, "startDate", now.minusYears(2));

            List<Record> records = session.executeRead(tx -> tx.run(query1, params2).list());
            for (Record record : records) {
                MangaDTO mangaDTO = (MangaDTO) recordToMediaContentDTO(record);
                if (!suggested.contains(mangaDTO))
                    suggested.add(mangaDTO);
                if (suggested.size() == n)
                    break;
            }

            remaining = n - suggested.size();
        }

        // if there are still not enough suggestions, add more results based on all likes
        if (remaining > 0) {
            String query2 = """
                MATCH (u:User {id: $userId})-[:FOLLOWS]->(f:User)-[r:LIKE]->(m:Manga)
                WHERE NOT (u)-[:LIKE]->(m)
                WITH m, COUNT(DISTINCT f) AS num_likes
                RETURN m AS manga
                ORDER BY num_likes DESC, m.title ASC
                LIMIT $n
                """;
            Value params3 = parameters("userId", userId, "n", n);

            List<Record> records = session.executeRead(tx -> tx.run(query2, params3).list());
            for (Record record : records) {
                MangaDTO mangaDTO = (MangaDTO) recordToMediaContentDTO(record);
                if (!suggested.contains(mangaDTO))
                    suggested.add(mangaDTO);
                if (suggested.size() == n)
                    break;
            }
        }

        return suggested.isEmpty() ? null : suggested;

    } catch (Neo4jException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());

    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Neo4j Query:
\end{itemize}
\begin{lstlisting}[language=Cypher]
// Match the User node with the specified userId who follows other User nodes,
// and those followed Users who have liked Anime nodes with a LIKE relationship and date constraint.
MATCH (u:User {id: $userId})-[:FOLLOWS]->(f:User)-[r:LIKE]->(a:Anime)
// Ensure that the User does not directly like the Anime and that the LIKE relationship's date is within the specified range.
WHERE NOT (u)-[:LIKE]->(a) AND r.date >= $startDate
// Aggregate the results to count the number of distinct Users who have liked each Anime node.
WITH a, COUNT(DISTINCT f) AS num_likes
// Return the Anime node, ordered by the number of likes in descending order.
RETURN a AS anime
ORDER BY num_likes DESC
// Limit the number of results returned to the specified maximum.
LIMIT $n    
\end{lstlisting}
\textbf{Get Suggested By Likes}\\
Retrieves a list of suggested MangaDTO objects for a user from the Neo4j database.
The method performs the following steps:\\
1. Retrieve Manga that other users with similar taste have liked in the last 6 months.\\
2. If there are not enough suggestions, retrieve Manga that other users with similar taste have liked in the last 2 years.\\
3. If there are still not enough suggestions, retrieve Manga that other users with similar taste have liked.\\
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public List<MediaContentDTO> getSuggestedByLikes(String userId, Integer limit) throws DAOException {
    try (Session session = getSession()) {
        int n = limit == null ? 5 : limit;
        int remaining;
        LocalDate today = LocalDate.now();

        // Try to get suggestions based on likes in the last 6 months
        String query1 = """
                MATCH (u:User {id: $userId})-[r1:LIKE]->(m:Manga)<-[:LIKE]-(f:User)
                WHERE r1.date >= $startDate
                WITH u, f, COUNT(m) AS common_likes
                ORDER BY common_likes DESC
                LIMIT 20
                MATCH (f)-[:LIKE]->(m2:Manga)
                WHERE NOT (u)-[:LIKE]->(m2)
                WITH m2, COUNT(DISTINCT f) AS num_likes
                RETURN m2 AS manga
                ORDER BY num_likes DESC, m2.title ASC
                LIMIT $n
                """;
        Value params1 = parameters("userId", userId, "n", n, "startDate", today.minusMonths(6));

        List<MediaContentDTO> suggested = session.executeRead(
                        tx -> tx.run(query1, params1).list()
                ).stream()
                .map(record -> (MangaDTO) recordToMediaContentDTO(record))
                .collect(Collectors.toList());

        remaining = n - suggested.size();

        // If there are not enough suggestions, add more results from the last 2 years
        if (remaining > 0) {
            Value params2 = parameters("userId", userId, "n", n, "startDate", today.minusYears(2));

            List<Record> records = session.executeRead(tx -> tx.run(query1, params2).list());
            for (Record record : records) {
                MangaDTO mangaDTO = (MangaDTO) recordToMediaContentDTO(record);
                if (!suggested.contains(mangaDTO))
                    suggested.add(mangaDTO);
                if (suggested.size() == n)
                    break;
            }

            remaining = n - suggested.size();
        }

        // If there are not enough suggestions, add more results based on all likes
        if (remaining > 0) {
            String query2 = """
                    MATCH (u:User {id: $userId})-[r1:LIKE]->(m:Manga)<-[:LIKE]-(f:User)
                    WITH u, f, COUNT(m) AS common_likes
                    ORDER BY common_likes DESC
                    MATCH (f)-[:LIKE]->(m2:Manga)
                    WHERE NOT (u)-[:LIKE]->(m2)
                    WITH m2, COUNT(DISTINCT f) AS num_likes
                    RETURN m2 AS manga
                    ORDER BY num_likes DESC, m2.title ASC
                    LIMIT $n
                    """;
            Value params3 = parameters("userId", userId, "n", n);

            List<Record> records = session.executeRead(tx -> tx.run(query2, params3).list());
            for (Record record : records) {
                MangaDTO mangaDTO = (MangaDTO) recordToMediaContentDTO(record);
                if (!suggested.contains(mangaDTO))
                    suggested.add(mangaDTO);
                if (suggested.size() == n)
                    break;
            }
        }

        return suggested.isEmpty() ? null : suggested;

    } catch (Neo4jException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());

    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Neo4j Query:
\end{itemize}
\begin{lstlisting}[language=Cypher]
// Match the User node with the specified userId who likes Anime nodes (r1) and those Anime nodes are liked by other Users (f).
MATCH (u:User {id: $userId})-[r1:LIKE]->(a:Anime)<-[:LIKE]-(f:User)
// Ensure that the User's LIKE relationship's date is within the specified range.
WHERE r1.date >= $startDate
// Aggregate the results to count the number of common Anime nodes liked by both the User (u) and other Users (f).
WITH u, f, COUNT(a) AS common_likes
// Order the results by the number of common likes in descending order and limit to 20 results.
ORDER BY common_likes DESC
LIMIT 20
// Match Users (f) who like Anime nodes (a2) that are not liked by the User (u).
MATCH (f)-[:LIKE]->(a2:Anime)
WHERE NOT (u)-[:LIKE]->(a2)
// Aggregate the results to count the number of distinct Users (f) who like each Anime node (a2).
WITH a2, COUNT(DISTINCT f) AS num_likes
// Return the Anime node (a2) ordered by the number of likes by distinct Users (num_likes) in descending order.
RETURN a2 AS anime
ORDER BY num_likes DESC
// Limit the number of Anime nodes returned to the specified maximum ($n).
LIMIT $n    
\end{lstlisting}





