\chapter{Implementation}

\section{Development Environment}
To ensure efficient and successful Implementation of MangaVerse web application,
choosing the appropriate development environment is one of the most important points of the project.

\subsection*{Programming Languages}
\begin{itemize}
    \item \textbf{Backend:} Java is the main programming language used in the project’s backend development.
    \item \textbf{Frontend:} HTML, CSS, JavaScript are utilized for building user interface in the project.
    \item \textbf{Data Preprocessing:} Python and java were used in the project to conduct data preprocessing task with the help of its powerful libraries and ease of use features. 
\end{itemize}

\subsection*{Database}
\begin{itemize}
    \item \textbf{Document Database:} MongoDB is used in the project to store and manage document-based data with the help of its flexibility and scalability features.
    \item \textbf{Graph Database:} Neo4j is used in the project to manage and query graph data and handle complex relationships and connections between user entities and media contents in an efficient way.
\end{itemize}

\subsection*{Integrated Development Environment} Intellij IDEA was used as an primary IDE. It is powerful Java 
integrated development environment for developing software in an efficient way.

\subsection*{Version Control} Github was used to provide a collaborative development with its version control system.

\subsection*{Web Server} Apache Tomcat was used as a web server to provide reliable environment for deploying and running the java based web application.

\subsection*{Build Automation} Maven was used as a build automation tool. It is used to manage the project's build, reporting, and documentation from a central piece of information.

\subsection*{Testing} JUnit was used as a testing framework for Java code. It is used to write and run repeatable automated tests. This ensures the reliability and efficiency of the codebase throughout the development process.





\section{Main Modules}
\begin{itemize}
    \item Configuration
    \item Controller
    \item DAO (Data Access Objects)
    \item DTO (Data Transfer Objects)
    \item Model 
    \item Service
    \item Utils
    \item User Interface
\end{itemize}
\subsection*{Configuration}
Configuration module contains a class named \textit{AppServletContextListener} which is responsible for 
initializing and managing database connections for the web application. The configuration class 
implements ServletContextListener interface. \textit{@WebListener} annotation is used to provide listening for 
application lifecycle events. This annotation contains two methods, which are \textit{contextInitialized(ServletContextEvent sce)} and
\textit{contextDestroyed(ServletContextEvent sce)}. The first method is called when the web application is started and the second method is called when the web application is shut down.\\ \\
\textbf{Database Connection Management:} Database connection is provided with \textit{openConnection()} and \textit{closeConnection()} methods. They are both initialized for managing connection
for MongoDB and Neo4j databases. Connections are managed with corresponding DAO classes which are BaseMongoDBDAO and BaseNeo4jDAO.\\ \\
With using the configuration module for database connection, web application ensures robustness and reliability in its data access layer.

\subsection*{Controller}
%%TODO: change the code when it is corrected 
The controller modules plays a role as intermediary between the user requests and backend of the MangaVerse wab application as servlet classes.
They receives the user requests, process them and returns with the corresponding response. The controller classes are implemented using HttpServlet to handle user requests and responses.
Within the scope of their intermediary role, the controller classes are responsible of being a bridge between the user interface and backend logic. 
When a user interacts with the web application, their actions are translated into a HTTP request and these requests are handled by the related servlet class in the controller module. 
To be able to do do request translation in an efficient way each controller class extend 'HttpServlet' and has various methods to handle HTTP requests like GET and POST. 
Each controller class utilized a switch-case structure to determine the action requested and invokes the appropriate handler method accordingly.
This structure allows for clear and organized routing of request to their corresponding handler method. After processing the request, the servlet generates a requested response.\\
\newline
\textbf{Example code snippet from MediaContentServlet:}
\begin{mdframed}[backgroundcolor=yellow!20, innerleftmargin=10pt, innerrightmargin=10pt]
    \begin{lstlisting}[language=java]
{
    protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String action = request.getParameter("action");

        switch (action) {
            case "toggleLike" -> handleToggleLike(request, response);
            case "addReview" -> handleAddReview(request, response);
            case "deleteReview" -> handleDeleteReview(request, response);
            case "editReview" -> handleEditReview(request, response);
            case "getMediaContent" -> handleGetMediaContentById(request,response);
            case "getMediaContentByTitle" -> handleSearchMediaContentByTitle(request,response);
            case null, default -> handleLoadPage(request,response);
        }
    }
}
    \end{lstlisting}
\end{mdframed}
The controller module contains the following classes:
\begin{itemize}
    \item Exception \\
    NotAuthorizedException: This exception is thrown when the user is not authorized to access the requested resource.
    \item AuthServlet \\
    The AuthServlet class handles the user authentication and authorization processes. It includes login, logout and sign up functions
    \item MainPageServlet \\
    The MainPageServlet class is responsible for handling the main page of the web application. It includes the main page of the web application and the search functionality.
    It provides request related to displaying main page and searching media contents.
    \item ManagerServlet \\
    The ManagerServlet class manages administrative requests in manager page. These request are primarily about manga, anime and user analytics such \textit{averageRatingByMonth(), trendMediaContentByYear(), getBestCriteria()...}
    \item MediaContentServlet \\
    The MediaContentServlet class is responsible for managing request related with media contents. These requests include like, adding,deleting or editing reviews and retrieving media content details. 
    \item ProfileServlet \\
    The ProfileServlet class is responsible for managing user profile related requests. These requests include updating user profile, following/unfollowing other users, getting user profile details such as liked anime and manga and user reviews.
    \item UserServlet \\
    The UserServlet class is responsible for managing user related requests and interactions. These requests include retrieving followers list, following list and user information. 
\end{itemize}

\subsection*{DAO (Data Access Objects)}
The DAO module includes the logic for accessing and managing data in the database and provides data retrieval, 
storage and manipulation. This module includes classes with CRUD (create, read, update, delete) operations and query executions. 
It provides a layer of abstraction between the database and the rest of the application and ensures the separation of concerns. The DAO module contains the following classes:
\begin{itemize}
    \item Enums \\
    - DataRepositoryEnum
    \item Exceptions 
    \item Interfaces \\
    - MedıaContentDAO \\
    - ReviewDAO \\
    - UserDAO 
    \item Mongo \\
    - AnimeDAOMongoImpl \\
    - BaseMongoDBDAO \\
    - MangaDAOMongoImpl \\
    - ReviewDAOMongoImpl \\
    - UserDAOMongoImpl 
    \item Neo4j \\
    - AnimeDAONeo4jImpl \\
    - BaseNeo4jDAO \\
    - MangaDAONeo4jImpl \\
    - UserDAONeo4jImpl 
    \item DAOLocator 
\end{itemize}
\newpage
\textbf{Example code snippet from MangaDAOMongoImpl:}
\begin{mdframed}[backgroundcolor=yellow!20, innerleftmargin=10pt, innerrightmargin=10pt]
    \begin{lstlisting}[language=java]
{
    //MongoDB queries
    //Best genres/themes/demographics/authors based on the average rating
    @Override
    public Map<String, Double> getBestCriteria (String criteria, boolean isArray, int page) throws DAOException {
        try  {
            MongoCollection<Document> mangaCollection = getCollection(COLLECTION_NAME);
            int pageOffset = (page-1)*Constants.PAGE_SIZE;

            List<Bson> pipeline;
            if (isArray) {
                pipeline = List.of(
                        match(and(exists(criteria), ne("average_rating", null))),
                        unwind("$" + criteria),
                        group("$" + criteria, avg("criteria_average_rating", "$average_rating")),
                        sort(descending("criteria_average_rating")),
                        skip(pageOffset),
                        limit(25)
                );
            } else {
                pipeline = List.of(
                        match(Filters.exists(criteria)),
                        group("$" + criteria, avg("criteria_average_rating", "$average_rating")),
                        sort(new Document("criteria_average_rating", -1)),
                        skip(pageOffset),
                        limit(25)
                );
            }

            List <Document> document = mangaCollection.aggregate(pipeline).into(new ArrayList<>());
            Map<String, Double> bestCriteria = new LinkedHashMap<>();
            for (Document doc : document) {
                Double avgRating = doc.get("criteria_average_rating") instanceof Integer?
                        doc.getInteger("criteria_average_rating").doubleValue() :
                        doc.getDouble("criteria_average_rating");
                if (criteria.equals("authors")) {
                    bestCriteria.put(doc.get("_id", Document.class).getString("name"), avgRating);
                } else {
                    bestCriteria.put(doc.get("_id").toString(), avgRating);
                }
            }

            return bestCriteria;

        } catch (Exception e) {
            throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
        }
    }
}
    \end{lstlisting}
\end{mdframed}


\newpage
\textbf{Example code snippet from UserDAONeo4jImpl:}
\begin{mdframed}[backgroundcolor=yellow!20, innerleftmargin=10pt, innerrightmargin=10pt]
    \begin{lstlisting}[language=java]
{
    /**
    * Retrieves a list of users following a specific user from the Neo4j database.
    *
    * @param userId The ID of the user whose followers are to be retrieved.
    * @param loggedUserId The ID of the user requesting the list of followers.
    * @return A list of RegisteredUserDTO objects representing the followers of the specified user.
    * @throws DAOException If an error occurs while retrieving the followers list.
    */
   @Override
   public List<UserSummaryDTO> getFirstNFollowers(String userId, String loggedUserId) throws DAOException {
       try (Session session = getSession()) {
           StringBuilder queryBuilder = new StringBuilder("MATCH (follower:User)-[:FOLLOWS]->(:User {id: $userId}) ");
           if (loggedUserId != null) {
               queryBuilder.append("WHERE follower.id <> $loggedUserId ");
           }
           queryBuilder.append("RETURN follower AS user ");
           queryBuilder.append("ORDER BY follower.username ");
           queryBuilder.append("LIMIT 10");
           String query = queryBuilder.toString();

           Map<String, Object> params = new HashMap<>();
           params.put("userId", userId);
           if (loggedUserId != null) {
               params.put("loggedUserId", loggedUserId);
           }

           List<Record> records = session.executeRead(
                   tx -> tx.run(query, params).list()
           );

           return records.isEmpty() ? null : records.stream()
                   .map(this::recordToUserSummaryDTO)
                   .toList();

       } catch (Neo4jException e) {
           throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());

       } catch (Exception e) {
           throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
       }
   }
}
    \end{lstlisting}
\end{mdframed}
\newpage


\subsection*{DTO (Data Transfer Objects)}
The DTO modules are the intermediary class between presentation layer and the DAO module in the web application.
They transfer data structures between different layers and components of the application in a more standardized way.


\subsection*{Model}
\begin{itemize}
    \item Enums
    \item Media Content \\
    - Anime\\
    - Manga \\
    - Manga Author \\
    - Media Content
    \item Registered User\\
    - Mangager\\
    - Registered User\\
    - User
    \item Review 
\end{itemize}

\subsection*{Service}
Service module has also important role in the web application. The classes in the service module are responsible for containing
the business logic and maintaining interaction between the DAO classes and the presentation layer. 
It handles complex operations with guarantying that the application's core functionalities are executed correctly. Some of the services
that are provided in the service module are: \textit{UserService, MediaContentService, ReviewService, TaskManager, ExecuterTaskService}. The 
package structure of Service module is as follows:





\begin{itemize}
    \item enums \\
    - ExecuterTaskService
    \item exceptions \\
    - enums \\
    ----- BusinessExceptionType \\
    - BusinessException
    \item impl \\
    - asinc media tasks\\
    ----- CreateMediaTask\\
    ----- DeleteMediaTask\\
    ----- UpdateAverageRatingTask\\
    ----- UpdateMediaRedundancyTask\\
    ----- UpdateMediaTask\\
    ----- UpdateNumberofLikesTask\\
    - asinc review tasks\\
    ----- RemoveDeletedMediaReviewsTask\\
    ----- RemoveDeletedUserReviewsTask\\
    ----- UpdateReviewRedundancyTask\\
    - asinc user tasks\\
    ----- CreateUserTask\\
    ----- DeleteUserTask\\
    ----- UpdateNumberOfFollowedTask\\
    ----- UpdateNumberOfFollowersTask\\
    ---- UpdateUserTask\\
    - AperiodicExecutorTaskServiceImpl\\
    - ErrorTaskManager\\
    - MediaContentServiceImpl\\
    - PeriodicExecutorTaskServiceImpl\\
    - ReviewServiceImpl\\
    - UserServiceImpl\\
    - interfaces \\
    ----- ExecuterTaskService\\
    ----- MediaContentService\\
    ----- ReviewService\\
    ----- Task\\
    ----- TaskManager\\
    ----- UserService
    \item ServiceLocator
\end{itemize}

\section{Adopted Patterns and Techniques}
\subsection*{Patterns}


\subsection*{Techniques}

\textbf{Task Manager:}\\
Task Manager class which is located in the service module of the system provides asynchronous task execution with using 
\textit{PriorityBlockingQueue}. It helps to order the tasks according to their prioritizes. 
After that prioritization, it ensures that higher priority tasks will be executed first and if two tasks have the 
same priority the one which is created before will be executed first. While Task Manager class is able to start and stop the tasks within the functions inside,
it can also take tasks to the queue in a thread-safe way. By using taskComparator for ordering the tasks,
the system provides also effective scheduling and execution. \\ \\
\textbf{Aperiodic Executor Task Service:}\\
Executor Task Service class which is located inside the service module of the system is an important part for providing the eventual consistency. Executing tasks in asynchronous way with threads guarantees
eventual consistency across different collections, mongoDB and neo4j and different replicas. 
With the help of the Executor Task Service, tasks that are needed to be executed in an asynchronous way are handled by ensuring that changes propagate correctly across different part of the system.
While using multiple databases and data replicas for this web application, it is important for maintain data integrity and eventual consistency.
Executing the tasks in an asynchronous way using threads allows to perform operations without blocking the main execution flow.
Aperiodic executer task service class is implemented by using the interface of executor service. 


\section{Description of Main Classes}

\subsection*{Controller}
\renewcommand{\arraystretch}{1.5}
\begin{longtable}{|>{\arraybackslash}p{0.33\linewidth}|>{\arraybackslash}p{0.66\linewidth}|}
    \hline
    \textbf{Class} & \textbf{Description} \\
    \hline
    \endfirsthead

    \hline
    \textbf{Class} & \textbf{Description} \\
    \hline
    \endhead

    \hline
    \endfoot

    \hline
    \endlastfoot

    AuthServlet & Handles business logic for authentication \\
    \hline
    MainPageServlet & Handles business logic for main page \\
    \hline
    ManagerServlet & Handles business logic for manager \\
    \hline
    MediaContentServlet & Handles business logic for media content \\
    \hline
    ProfileServlet & Handles business logic for profile \\
    \hline
    UserServlet & Handles business logic for user \\
    \hline
\end{longtable}

\newpage

\subsection*{DAO}
\renewcommand{\arraystretch}{1.5}
\begin{longtable}{|>{\raggedright\arraybackslash}p{0.3\linewidth}|>{\raggedright\arraybackslash}p{0.1\linewidth}|>{\raggedright\arraybackslash}p{0.6\linewidth}|}
    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endfirsthead

    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endhead

    \hline
    \endfoot

    \hline
    \endlastfoot

    MediaContentDAO & interfaces & Collection of methods for media content database related entities on mongoDB \\
    \hline
    ReviewDAO B & interfaces & Collection of methods for review database related entities on mongoDB \\
    \hline
    UserDAO & interfaces & Collection of methods for user database related entities on mongoDB \\
    \hline
    AnimeDAOMongoImpl & mongo & Contains all the method implementation for the MongoDB database anime entities \\
    \hline      
    BaseMongoDBDAO & mongo & Contains all the method implementations for the MongoDB database \\
    \hline
    MangaDAOMongoImpl & mongo & Contains all the method implementations for the MongoDB database manga entities \\
    \hline
    ReviewDAOMongoImpl & mongo & Contains all the method implementations for the MongoDB database review entities \\
    \hline
    UserDAOMongoImpl & mongo & Contains all the method implementations for the MongoDB database user entities \\
    \hline
    AnimeDAONeo4jImpl & neo4j & Contains all the method implementation for the Neo4j database anime entities \\
    \hline
    BaseNeo4jDAO & neo4j & Contains all the method implementations for the Neo4j database \\
    \hline
    MangaDAONeo4jImpl & neo4j & Contains all the method implementation for the Neo4j database manga entities \\
    \hline
    UserDAONeo4jImpl & neo4j & Contains all the method implementation for the Neo4j database user entities \\
    \hline
    DAOLocator & & Implements the locator pattern for accessing DAOs based on the specified data repository \\
    \hline
\end{longtable}

\subsection*{DTO}
\renewcommand{\arraystretch}{1.5}
\begin{longtable}{|>{\raggedright\arraybackslash}p{0.25\linewidth}|>{\raggedright\arraybackslash}p{0.15\linewidth}|>{\raggedright\arraybackslash}p{0.6\linewidth}|}
    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endfirsthead

    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endhead

    \hline
    \endfoot

    \hline
    \endlastfoot

    AnimeDTO & mediaContent & Represents data transfer object containing attributes for animes \\
    \hline
    MangaDTO & mediaContent & Represents data transfer object containing attributes for mangas \\
    \hline
    MediaContentDTO & interfaces & Defines common attributes for media content \\
    \hline
    DashboardDTO & statistics & Contains statistical data for the dashboard \\
    \hline
    MongoDBStats & statistics & Provides statistics specific to MongoDB \\
    \hline
    LoggedUserDTO & & Holds information about a logged-in user. \\
    \hline
    PageDTO & & Represents pagination details \\
    \hline
    ReviewDTO & & Contains attributes for reviews \\
    \hline
    UserRegistrationDTO & & Holds data for user registration \\
    \hline
    UserSummaryDTO & & Provides a summary of user information \\
    \hline
\end{longtable}


\subsection*{Model}
\renewcommand{\arraystretch}{1.5}
\begin{longtable}{|>{\raggedright\arraybackslash}p{0.25\linewidth}|>{\raggedright\arraybackslash}p{0.15\linewidth}|>{\raggedright\arraybackslash}p{0.6\linewidth}|}
    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endfirsthead

    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endhead

    \hline
    \endfoot

    \hline
    \endlastfoot

    Anime & mediaContent & Provides unique anime attributes by extending parent class MediaContent and related getter and setter methods. \\
    \hline
    Manga & mediaContent & Provides unique manga attributes by extending parent class MediaContent and related getter and setter methods. \\
    \hline
    MangaAuthor & mediaContent & Contains manga author attributes and related getter and setter methods. \\
    \hline
    MediaContent & mediaContent & Contains all the attributes used by types of media contents and their getter and setter methods. \\
    \hline
    Manager & registeredUser & Provides unique manager attributes by extending parent class RegisteredUser and related getter and setter methods. \\
    \hline
    RegisteredUSer & registeredUser & Contains all the attributes used by types of registered users and their getter and setter methods. \\
    \hline
    User & registeredUser & Provides unique user attributes by extending parent class RegisteredUser and related getter and setter methods. \\
    \hline
    Review &  & Contains review attributes and related getter and setter methods. \\
    \hline
\end{longtable}



\subsection*{Service}
\renewcommand{\arraystretch}{1.5} % Adjusts the row height
\begin{longtable}{|>{\raggedright\arraybackslash}p{0.3\linewidth}|>{\raggedright\arraybackslash}p{0.2\linewidth}|>{\raggedright\arraybackslash}p{0.5\linewidth}|}
   
    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endfirsthead

    \hline
    \textbf{Class} & \textbf{Sub-package} & \textbf{Description} \\
    \hline
    \endhead

    \hline
    \endfoot

    \hline
    \endlastfoot

    CreateMediaTask & impl/ asinc\_media\_tasks & Implementation of methods for media task creation for MediaContentService \\
    \hline
    DeleteMediaTask B & impl/ asinc\_media\_tasks & Implementation of methods for media task deletion for MediaContentService \\
    \hline
    RefreshLatestReviewsTasks & impl/ asinc\_media\_tasks & Implementation of methods for refreshing latest reviews for MediaContentService \\
    \hline
    UpdateAverageRatingTask & impl/ asinc\_media\_tasks & Implementation of methods for updating average rating for MediaContentService \\
    \hline
    UpdateMediaRedundancyTask & impl/ asinc\_media\_tasks & Implementation of methods for updating media redundancy for MediaContentService \\
    \hline
    UpdateMediaTask & impl/ asinc\_media\_tasks & Implementation of methods for updating media for MediaContentService \\
    \hline
    UpdateNumberofLikesTask & impl/ asinc\_media\_tasks & Implementation of methods for updating numbers of likes for MediaContentService \\
    \hline
    RemoveDeletedMedia ReviewsTask & impl/ asinc\_review\_tasks & Implementation of methods for removing reviews of deleted media for ReviewService \\
    \hline
    RemoveDeletedUser ReviewsTask & impl/ asinc\_review\_tasks & Implementation of methods for removing reviews of deleted user for ReviewService \\
    \hline
    UpdateReviewRedundancyTask & impl/ asinc\_review\_tasks & Implementation of methods for updating review redundancy for ReviewService \\
    \hline
    CreateUserTask & impl/ asinc\_user\_tasks & Implementation of methods for user creation for UserService \\
    \hline
    DeleteUserTask & impl/ asinc\_user\_tasks & Implementation of methods for user deletion for UserService \\
    \hline
    UpdateNumberOfFollowedTask B & impl/ asinc\_user\_tasks & Implementation of methods for updating number of followed for UserService \\
    \hline
    UpdateNumberOfFollowersTask & impl/ asinc\_user\_tasks & Implementation of methods for updating number of followers for UserService \\
    \hline
    UpdateUserTask & impl/ asinc\_user\_tasks & Implementation of methods for updating user for MediaContentService \\
    \hline
    AperiodicExecutor TaskServiceImpl & impl & Implementation of aperiodic tasks for ExecutorTaskService \\
    \hline
    ErrorTaskManager & impl & Implementation of TaskManager interface to handle error \\
    \hline
    MediaContentServiceImpl & impl & Implementation of MediaContentService, providing media content operations \\
    \hline
    PeriodicExecutor TaskServiceImpl & impl & Implementation of periodic tasks for ExecutorTaskService \\
    \hline
    ReviewServiceImpl & impl & Implementation of ReviewService, providing review operations \\
    \hline
    UserServiceImpl & impl & Implementation of UserService, providing user operations \\
    \hline
    ExecutorTaskService & interfaces & Collection of methods for task management \\
    \hline
    MediaContentService & interfaces & Collection of methods for media content service \\
    \hline
    ReviewService & interfaces & Collection of methods for review service \\
    \hline
    Task & interfaces & Collection of methods for execution operations \\
    \hline
    TaskManager & interfaces & Collection of methods for managing task prioritization \\
    \hline
    UserService & interfaces & Collection of methods for user service \\
    \hline
    ServiceLocator & & Implements locator pattern for services \\
    \hline
\end{longtable}



\newpage
\section {MongoDB queries}
Some of the most important MongoDB queries for analytic and suggestion purposes. 

\subsection*{USER:}
\textbf{Get Distribution}\\
GetDistribution query to get the user's location, birthday year that gave the highest rating to the application
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public Map<String, Integer> getDistribution(String criteria) throws DAOException {
    try {
        MongoCollection<Document> usersCollection = getCollection(COLLECTION_NAME);

        List<Bson> pipeline = new ArrayList<>();
        if (criteria.equals("birthday") || criteria.equals("joined_on")) {
            pipeline.addAll(List.of(
                    match(exists(criteria)),
                    project(fields(computed("year", new Document("$year", "$" + criteria)), include("app_rating" ))),
                    group("$year", sum("count", 1)),
                    sort(descending("count"))));
        } else if (criteria.equals("location") || criteria.equals("gender")) {
            pipeline.addAll(List.of(
                    match(exists(criteria)),
                    project(fields(include(criteria, "app_rating"))),
                    group("$" + criteria, sum("count", 1)),
                    sort(descending("count"))));
        } else {
            throw new Exception("UserDAOMongoImpl: getDistribution: Invalid criteria");
        }

        List<Document> aggregationResult = usersCollection.aggregate(pipeline).into(new ArrayList<>());
        if (aggregationResult.isEmpty()) {
            throw new MongoException("UserDAOMongoImpl: getDistribution: No data found");
        }

        Map<String,Integer> map = new LinkedHashMap<>();
        for (Document doc : aggregationResult) {
            if (criteria.equals("birthday") || criteria.equals("joined_on")) {
                map.put(String.valueOf(doc.getInteger("_id")), doc.getInteger("count"));
            } else {
                map.put(doc.getString("_id"), doc.getInteger("count"));
            }
        }
        return map;

    } catch (MongoException e){
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());
    } catch (Exception e){
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}

\begin{itemize}
    \item Mongo Shell Query:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
    // Match stage to filter documents where 'criteriaOfSearch' exists
    db.collection.aggregate([
        {
            $match: {
                [criteriaOfSearch]: { $exists: true }
            }
        },
        // Project stage to include 'criteriaOfSearch' and 'app_rating' fields
        {
            $project: {
                [criteriaOfSearch]: 1,
                app_rating: 1
            }
        },
        // Group stage to count occurrences of each 'criteriaOfSearch'
        {
            $group: {
                _id: "$" + criteriaOfSearch,
                count: { $sum: 1 }
            }
        },
        // Sort stage to sort documents by 'count' in descending order
        {
            $sort: {
                count: -1
            }
        }
    ]);     


\end{lstlisting} 
\textbf{Average App Rating}\\
Calculates the average application rating based on the specified search criteria
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
    public Map<String, Double> averageAppRating(String criteria) throws DAOException {
    try {
        MongoCollection<Document> usersCollection = getCollection(COLLECTION_NAME);

        List<Bson> pipeline = List.of(
                match(and(exists(criteria), exists("app_rating"))),
                group("$" + criteria, avg("averageAppRating", "$app_rating")),
                sort(descending("averageAppRating"))
        );

        List<Document> aggregationResult = usersCollection.aggregate(pipeline).into(new ArrayList<>());
        if (aggregationResult.isEmpty()) {
            throw new MongoException("UserDAOMongoImpl: averageAppRating: No data found");
        }

        Map<String,Double> map = new LinkedHashMap<>();
        for (Document doc : aggregationResult) {
            map.put(doc.getString("_id"), doc.getDouble("averageAppRating"));
        }
        return map;

    } catch (MongoException e){
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());
    }
    catch (Exception e){
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
        
    \begin{itemize}
        \item Mongo Shell Query:
    \end{itemize}
    \begin{lstlisting}[language=JavaScript]
db.getCollection.aggregate([
    { 
        $match: { 
                $and: [
                { [criteria]: { $exists: true } },
                { app_rating: { $exists: true } }
            ]
        } 
    },
    { 
        $group: { 
            _id: "$" + criteria, 
            averageAppRating: { $avg: "$app_rating" }
        } 
    },
    { 
        $sort: { 
            averageAppRating: -1 
        } 
    }
]).toArray();      
        
\end{lstlisting}
\textbf{Average App Rating By Age}\\
Calculates the average app rating for users grouped by age ranges.
The age ranges are defined as follows:\\
- 0-13 years\\
- 13-20 years\\
- 20-30 years\\
- 30-40 years\\
- 40-50 years\\
- 50+ years
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public Map<String, Double> averageAppRatingByAgeRange() throws DAOException {
    try {
        MongoCollection<Document> usersCollection = getCollection(COLLECTION_NAME);

        // Define the boundaries for the age ranges and the output fields
        List<Long> boundaries = Arrays.asList(0L, 13L, 20L, 30L, 40L, 50L);
        BsonField[] outputFields = {
                new BsonField("avg_app_rating", new Document("$avg", "$app_rating"))
        };
        BucketOptions options = new BucketOptions()
                .defaultBucket(50L)
                .output(outputFields);

        List<Bson> pipeline = List.of(
                match(and(exists("birthday"), exists("app_rating"))),
                project(fields(
                        computed("age", new Document("$floor", new Document("$divide",
                        Arrays.asList(
                                new Document("$subtract", Arrays.asList(new Date(), "$birthday")),
                                1000L * 60 * 60 * 24 * 365
                        )))),
                        include("app_rating")
                )),
                bucket("$age", boundaries, options)
        );

        List<Document> aggregationResult = usersCollection.aggregate(pipeline).into(new ArrayList<>());

        if (aggregationResult.isEmpty()) {
            throw new MongoException("UserDAOMongoImpl: averageAppRatingByAgeRange: No data found");
        }

        Map<String, Double> map = new LinkedHashMap<>();
        for (Document doc : aggregationResult) {
            String ageRange = convertIntegerToAgeRange(doc.getLong("_id"));
            map.put(ageRange, doc.getDouble("avg_app_rating"));
        }

        return map;

    } catch (MongoException e){
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());
    } catch (Exception e){
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
    
\begin{itemize}
    \item Mongo Shell Query:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
db.getCollection('COLLECTION_NAME').aggregate([
    { 
        $match: { 
            $and: [
                { birthday: { $exists: true } }, 
                { app_rating: { $exists: true } }
            ]
        } 
    },
    { 
        $project: { 
            age: { 
                $floor: { 
                    $divide: [
                        { $subtract: [ new Date(), "$birthday" ] },
                        1000 * 60 * 60 * 24 * 365
                    ]
                }
            },
            app_rating: 1 
        } 
    },
    { 
        $bucket: {
            groupBy: "$age",
            boundaries: [0, 13, 20, 30, 40, 50],
            default: 50,
            output: { 
                avg_app_rating: { $avg: "$app_rating" }
            }
        }
    }
]).toArray();
       
    
\end{lstlisting}





\subsection*{REVIEW:}
\textbf{Get Media Content Rating By Year}\\
Retrieves the average ratings for a specific media content (anime or manga) by year within a specified range.
The aggregation pipeline performs the following steps:\\
1. Matches the reviews for the specified media content ID and date range, ensuring the reviews have a rating.\\
2. Groups the reviews by year and calculates the average rating for each year.\\
3. Projects the results to include the year and the calculated average rating.\\
4. Sorts the results by year in ascending order.
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public Map<String, Double> getMediaContentRatingByYear(MediaContentType type, String mediaContentId, int startYear, int endYear) throws  DAOException {
    try  {
        // Get media content rating by year
        MongoCollection<Document> reviewCollection = getCollection(COLLECTION_NAME);

        String nodeType = type.equals(MediaContentType.ANIME) ? "anime" : "manga";
        Date startDate = ConverterUtils.localDateToDate(LocalDate.of(startYear, 1, 1));
        Date endDate = ConverterUtils.localDateToDate(LocalDate.of(endYear + 1, 1, 1));
        List<Bson> pipeline = List.of(
                match(and(
                        eq(nodeType + ".id", new ObjectId(mediaContentId)),
                        exists("rating", true),
                        gte("date", startDate),
                        lt("date", endDate)
                )),
                group(new Document("$year", "$date"), avg("average_rating", "$rating")),
                project(fields(
                        excludeId(),
                        computed("year", "$_id"),
                        include("average_rating"))
                ),
                sort(ascending("year"))
        );
        List<Document> result = reviewCollection.aggregate(pipeline).into(new ArrayList<>());

        // Initialize the result map with years and default values
        Map<String, Double> resultMap = new LinkedHashMap<>();
        for (int year = startYear; year <= endYear; year++) {
            resultMap.put(String.valueOf(year), null);
        }

        // Populate the result map with the average ratings
        for (Document document : result) {
            Double averageRating = document.getDouble("average_rating");
            Integer year = document.getInteger("year");
            resultMap.put(String.valueOf(year), averageRating);
        }
        return resultMap;

    } catch (MongoException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());
    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
    
\begin{itemize}
    \item Mongo Shell Query:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
// Match stage to filter documents based on specified conditions
db.collection.aggregate([
    {
        $match: {
            [`${nodeType}.id`]: new ObjectId(mediaContentId),
            rating: { $exists: true },
            date: { $gte: startDate, $lt: endDate }
        }
    },
    // Group stage to group documents by year and calculate the average rating
    {
        $group: {
            _id: { $year: "$date" },
            average_rating: { $avg: "$rating" }
        }
    },
    // Project stage to shape the output documents
    {
        $project: {
            _id: 0,
            year: "$_id",
            average_rating: 1
        }
    },
    // Sort stage to sort documents by year in ascending order
    {
        $sort: { year: 1 }
    }
]);
\end{lstlisting}
\textbf{Get Media Content Rating By Month}\\
Retrieves the average ratings for a specific media content (anime or manga) by month for a specified year.
The aggregation pipeline performs the following steps:\\
1. Matches the reviews for the specified media content ID and year, ensuring the reviews have a rating.\\
2. Groups the reviews by month and calculates the average rating for each month.\\
3. Projects the results to include the month and the calculated average rating.\\
4. Sorts the results by month in ascending order.
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public Map<String, Double> getMediaContentRatingByMonth(MediaContentType type, String mediaContentId, int year) throws DAOException {
    try  {
        // Get media content rating by month
        MongoCollection<Document> reviewCollection = getCollection(COLLECTION_NAME);

        String nodeType = type.equals(MediaContentType.ANIME) ? "anime" : "manga";
        Date startDate = ConverterUtils.localDateToDate(LocalDate.of(year, 1, 1));
        Date endDate = ConverterUtils.localDateToDate(LocalDate.of(year + 1, 1, 1));
        List<Bson> pipeline = List.of(
                match(and(
                        eq(nodeType + ".id", new ObjectId(mediaContentId)),
                        exists("rating", true),
                        gte("date", startDate),
                        lt("date", endDate)
                )),
                group(new Document("$month", "$date"),
                        avg("average_rating", "$rating")
                ),
                project(fields(
                        excludeId(),
                        computed("month", "$_id"),
                        include("average_rating")
                )),
                sort(ascending("month"))
        );
        List<Document> result = reviewCollection.aggregate(pipeline).into(new ArrayList<>());

        // Initialize the result map with months and default values
        Map<String, Double> resultMap = new LinkedHashMap<>();
        for (Month month : Month.values()) {
            resultMap.put(month.getDisplayName(TextStyle.FULL, Locale.ENGLISH), null);
        }

        // Populate the result map with the average ratings
        for (Document document : result) {
            Object ratingObj = document.get("average_rating");
            Double averageRating = ratingObj instanceof Integer ratingInt ? ratingInt.doubleValue() : (Double) ratingObj;
            Integer month = document.getInteger("month");
            resultMap.put(Month.of(month).getDisplayName(TextStyle.FULL, Locale.ENGLISH), averageRating);
        }
        return resultMap;

    } catch (MongoException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());
    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Mongo Shell Query:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
db.getCollection.aggregate([
    { 
        $match: { 
            $and: [
                { [nodeType + ".id"]: mediaContentId },
                { rating: { $exists: true } },
                { date: { $gte: startDate } },
                { date: { $lt: endDate } }
            ]
        } 
    },
    { 
        $group: { 
            _id: { $month: "$date" },
            average_rating: { $avg: "$rating" }
        } 
    },
    { 
        $project: { 
            _id: 0,
            month: "$_id",
            average_rating: 1
        } 
    },
    { 
        $sort: { 
            month: 1 
        } 
    }
]).toArray();
\end{lstlisting}
\textbf{Suggest Media Content}\\
Suggests media content (anime or manga) based on user criteria (location or birthday year).
The aggregation pipeline performs the following steps:\\
1. Matches the reviews with a rating, the specified media content type and the user criteria.\\
2. Groups the reviews by media content ID and calculates the average rating for each media content.\\
3. Projects the results to include the media content title and the calculated average rating.\\
4. Sorts the results by average rating in descending order.\\
5. Limits the results to 20 entries.
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public List<MediaContentDTO> suggestMediaContent(MediaContentType mediaContentType, String criteriaType, String criteriaValue) throws DAOException {
    try  {
        // Suggest media content based on user criteria
        MongoCollection<Document> reviewCollection = getCollection(COLLECTION_NAME);
        String nodeType = mediaContentType.equals(MediaContentType.ANIME) ? "anime" : "manga";

        Bson filter = and(
                exists("rating", true),
                exists(nodeType, true)
        );

        if (criteriaType.equals("location")) {
            filter = and(filter, eq("user.location", criteriaValue));
        } else if (criteriaType.equals("birthday")) {
            Date startDate = ConverterUtils.localDateToDate(LocalDate.of(Integer.parseInt(criteriaValue), 1, 1));
            Date endDate = ConverterUtils.localDateToDate(LocalDate.of(Integer.parseInt(criteriaValue) + 1, 1, 1));
            filter = and(filter, gte("user.birthday", startDate), lt("user.birthday", endDate));
        } else {
            throw new Exception("ReviewDAOMongoImpl: suggestMediaContent: Invalid criteria type");
        }

        List<Bson> pipeline = new ArrayList<>(List.of(
                match(filter),
                group("$" + nodeType + ".id",
                        first("title", "$" + nodeType + ".title"),
                        avg("average_rating", "$rating")),
                sort(descending("average_rating")),
                project(include("title")),
                limit(20)));

        List<Document> result = reviewCollection.aggregate(pipeline).into(new ArrayList<>());
        if (result.isEmpty()) {
            throw new MongoException("ReviewDAOMongoImpl: suggestMediaContent: No reviews found");
        }

        List<MediaContentDTO> entries = new ArrayList<>();
        for (Document document : result) {
            String contentId = String.valueOf(document.getObjectId("_id"));
            String title = document.getString("title");

            MediaContentDTO mediaContentDTO;
            if (nodeType.equals("anime")) {
                mediaContentDTO = new AnimeDTO(contentId, title);
            } else {
                mediaContentDTO = new MangaDTO(contentId, title);
            }
            entries.add(mediaContentDTO);
        }
        return entries;

    } catch (MongoException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());
    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Mongo Shell Query:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
db.collection.aggregate([
    {
        // Match documents based on a dynamic user criteria
        $match: {
        ["user." + criteriaType]: criteriaValue
        }
    },
    {
        // Group documents by node type ID and calculate the first title and average rating
        $group: {
        _id: "$" + nodeType + ".id", // Group by the node type's ID
        title: { $first: "$" + nodeType + ".title" }, // Get the first title in the group
        average_rating: { $avg: "$rating" } // Calculate the average rating for the group
        }
    },
    {
        // Sort the grouped documents by average rating in descending order
        $sort: { average_rating: -1 }
    },
    {
        // Limit the number of results to the page size constant
        $limit: Constants.PAGE_SIZE
    }
    ]);
\end{lstlisting}


\subsection*{MANGA/ANIME:}
\textbf{Get Best Criteria}\\
Retrieves the best criteria based on the average rating of the Anime objects in the MongoDB database.
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public Map<String, Double> getBestCriteria (String criteria, boolean isArray, int page) throws DAOException {
    try {
        MongoCollection<Document> animeCollection = getCollection(COLLECTION_NAME);
        int pageOffset = (page - 1) * Constants.PAGE_SIZE;

        List<Bson> pipeline;
        if (isArray) {
            pipeline = List.of(
                    match(and(exists(criteria), ne("average_rating", null))),
                    unwind("$" + criteria),
                    group("$" + criteria, avg("criteria_average_rating", "$average_rating")),
                    sort(descending("criteria_average_rating")),
                    skip(pageOffset),
                    limit(25)
            );
        } else {
            pipeline = List.of(
                    match(Filters.exists(criteria)),
                    group("$" + criteria, avg("criteria_average_rating", "$average_rating")),
                    sort(new Document("criteria_average_rating", -1)),
                    skip(pageOffset),
                    limit(25)
            );
        }

        List <Document> document = animeCollection.aggregate(pipeline).into(new ArrayList<>());
        Map<String, Double> bestCriteria = new LinkedHashMap<>();
        for (Document doc : document) {
            Double avgRating = doc.get("criteria_average_rating") instanceof Integer?
                    doc.getInteger("criteria_average_rating").doubleValue() :
                    doc.getDouble("criteria_average_rating");
            bestCriteria.put(doc.get("_id").toString(), avgRating);
        }

        return bestCriteria;

    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Mongo Shell Query:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
db.collection.aggregate([
    // Match stage to filter documents where 'criteria' exists and 'average_rating' is not null
    {
        $match: {
            criteria: { $exists: true },
            average_rating: { $ne: null }
        }
    },
    // Unwind stage to deconstruct the 'criteria' array field
    {
        $unwind: "$" + criteria
    },
    // Group stage to calculate the average rating for each criteria
    {
        $group: {
            _id: "$" + criteria,
            criteria_average_rating: { $avg: "$average_rating" }
        }
    },
    // Sort stage to sort documents by 'criteria_average_rating' in descending order
    {
        $sort: {
            criteria_average_rating: -1
        }
    },
    // Skip stage to skip the first 'pageOffset' documents
    {
        $skip: pageOffset
    },
    // Limit stage to limit the results to 25 documents
    {
        $limit: 25
    }
]);
\end{lstlisting}




\newpage


  
\section{GraphDB queries}
Some of the most important Neo4j queries for analytic and suggestion purposes.
\subsection*{USERS:}
\textbf{Suggest User By Common Likes}\\
Retrieves a list of suggested users for a specific user based on common likes from the Neo4j database.
The method performs the following steps:\\
1. Retrieve users who like the same media content as the specified user in the last 6 month.\\
2. Retrieve users who like the same media content as the specified user in the last year.\\
3. Retrieve users who like the same media content as the specified user.\\
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public List<UserSummaryDTO> suggestUsersByCommonLikes(String userId, Integer limit, MediaContentType type) throws DAOException {

    try (Session session = getSession()) {
        if (type == null) {
            throw new IllegalArgumentException("Media content type must be specified");
        }

        int n = limit == null ? 5 : limit;
        int remaining;

        StringBuilder queryBuilder = new StringBuilder();
        if (type == MediaContentType.ANIME)
            queryBuilder.append("MATCH (u:User {id: $userId})-[r:LIKE]->(media:Anime)<-[:LIKE]-(suggested:User) ");
        else
            queryBuilder.append("MATCH (u:User {id: $userId})-[r:LIKE]->(media:Manga)<-[:LIKE]-(suggested:User) ");
        queryBuilder.append("""
                WHERE u <> suggested AND r.date >= date($date)
                WITH suggested, COUNT(DISTINCT media) AS commonLikes
                WHERE commonLikes > $min
                RETURN suggested AS user, commonLikes
                ORDER BY commonLikes DESC
                LIMIT $n
                """);
        String query1 = queryBuilder.toString();
        Value params1 = parameters("userId", userId, "n", n, "date", LocalDate.now().minusMonths(6), "min", 5);

        List<UserSummaryDTO> suggested = session.executeRead(
                tx -> tx.run(query1, params1).list()
        ).stream()
                .map(this::recordToUserSummaryDTO)
                .collect(Collectors.toList());

        remaining = n - suggested.size();

        if (remaining > 0) {
            Value params2 = parameters("userId", userId, "n", n, "date", LocalDate.now().minusYears(1), "min", 5);

            List<Record> records = session.executeRead(tx -> tx.run(query1, params2).list());
            for (Record record : records) {
                UserSummaryDTO userDTO = recordToUserSummaryDTO(record);
                if (!suggested.contains(userDTO))
                    suggested.add(userDTO);
                if (suggested.size() == n)
                    break;
            }

            remaining = n - suggested.size();
        }

        if(remaining > 0) {
            StringBuilder queryBuilder3 = new StringBuilder();
            if (type == MediaContentType.ANIME)
                queryBuilder3.append("MATCH (u:User {id: $userId})-[r:LIKE]->(media:Anime)<-[:LIKE]-(suggested:User) ");
            else
                queryBuilder3.append("MATCH (u:User {id: $userId})-[r:LIKE]->(media:Manga)<-[:LIKE]-(suggested:User) ");
            queryBuilder3.append("""
                    WHERE u <> suggested
                    WITH suggested, COUNT(DISTINCT media) AS commonLikes
                    RETURN suggested AS user, commonLikes
                    ORDER BY commonLikes DESC
                    LIMIT $n
                    """);
            String query2 = queryBuilder3.toString();
            Value params3 = parameters("userId", userId, "n", n);

            List<Record> records = session.executeRead(tx -> tx.run(query2, params3).list());
            for (Record record : records) {
                UserSummaryDTO userDTO = recordToUserSummaryDTO(record);
                if (!suggested.contains(userDTO))
                    suggested.add(userDTO);
                if (suggested.size() == n)
                    break;
            }
        }

        return suggested.isEmpty() ? null : suggested;

    } catch (Neo4jException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());

    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Neo4j Query:
\end{itemize}
\begin{lstlisting}[language=Cypher]
MATCH (u:User {id: $userId})-[r:LIKE]->(media:Manga)<-[:LIKE]-(suggested:User) 
WHERE u <> suggested AND r.date >= $date
WITH suggested, COUNT(DISTINCT media) AS commonLikes
WHERE commonLikes > $min
RETURN suggested AS user, commonLikes
ORDER BY commonLikes DESC
LIMIT $n
\end{lstlisting}
\textbf{Suggest Users By Common Followings}\\
Retrieves a list of suggested users for a specific user based on common followings from the Neo4j database.
The method performs the following steps:\\
1. Retrieve users that follow user's followings and have more than 5 common followings.\\
2. Retrieve users that are followed by user's followings and have more than 5 connections.\\
3. Retrieve users that follow user's followings.\\
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public List<UserSummaryDTO> suggestUsersByCommonFollowings(String userId, Integer limit) throws DAOException {
    try (Session session = getSession()) {
        int n = limit == null ? 5 : limit;
        int remaining;

        // suggest users that follow user's followings and have more than 5 common followings
        String query = """
                MATCH (u:User {id: $userId})-[:FOLLOWS]->(following:User)<-[:FOLLOWS]-(suggested:User)
                WHERE NOT (u)-[:FOLLOWS]->(suggested) AND u <> suggested
                WITH suggested, COUNT(DISTINCT following) AS commonFollowings
                WHERE commonFollowings > 5
                RETURN suggested as user
                ORDER BY commonFollowings DESC
                LIMIT $n
                """;
        Value params = parameters("userId", userId, "n", n);

        List<UserSummaryDTO> suggested = session.executeRead(
                tx -> tx.run(query, params).list()
        ).stream()
                .map(this::recordToUserSummaryDTO)
                .collect(Collectors.toList());

        remaining = n - suggested.size();

        // if there are not enough suggestions, suggest users that are followed by the user's followings and have more than 5 connections
        if (remaining > 0) {
            String query2 = """
                    MATCH (u:User {id: $userId})-[:FOLLOWS]->(following:User)-[:FOLLOWS]->(suggested:User)
                    WHERE NOT (u)-[:FOLLOWS]->(suggested) AND u <> suggested
                    WITH suggested, COUNT(DISTINCT following) AS commonUsers
                    WHERE commonUsers > 5
                    RETURN suggested as user
                    ORDER BY commonUsers DESC
                    LIMIT $n
                    """;
            Value params2 = parameters("userId", userId, "n", n);

            List<Record> records = session.executeRead(tx -> tx.run(query2, params2).list());
            for (Record record : records) {
                UserSummaryDTO userDTO = recordToUserSummaryDTO(record);
                if (!suggested.contains(userDTO))
                    suggested.add(userDTO);
                if (suggested.size() == n)
                    break;
            }

            remaining = n - suggested.size();
        }

        // if there are still not enough suggestions, suggest users that follow the user's followings
        if (remaining > 0) {
            String query3 = """
                    MATCH (u:User {id: $userId})-[:FOLLOWS]->(following:User)<-[:FOLLOWS]-(suggested:User)
                    WHERE NOT (u)-[:FOLLOWS]->(suggested) AND u <> suggested
                    WITH suggested, COUNT(DISTINCT following) AS commonFollowings
                    RETURN suggested as user
                    ORDER BY commonFollowings DESC
                    LIMIT $n
                    """;
            Value params3 = parameters("userId", userId, "n", n);

            List<Record> records = session.executeRead(tx -> tx.run(query3, params3).list());
            for (Record record : records) {
                UserSummaryDTO userDTO = recordToUserSummaryDTO(record);
                if (!suggested.contains(userDTO))
                    suggested.add(userDTO);
                if (suggested.size() == n)
                    break;
            }
        }

        return suggested.isEmpty() ? null : suggested;

    } catch (Neo4jException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());

    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Neo4j Query:
\end{itemize}
\begin{lstlisting}[language=Cypher]
MATCH (u:User {id: $userId})-[:FOLLOWS]->(following:User)<-[:FOLLOWS]-(suggested:User) 
WHERE NOT (u)-[:FOLLOWS]->(suggested) AND u <> suggested 
WITH suggested, COUNT(DISTINCT following) AS commonFollowers 
WHERE commonFollowers > 5 
RETURN suggested as user, commonFollowers 
ORDER BY commonFollowers DESC 
LIMIT $n
\end{lstlisting}


\subsection*{ANIME/MANGA:}
\textbf{Get Trend Media Content By Year}\\
Retrieves a list of trending MangaDTO objects for a specific year from the Neo4j database.
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public Map<MediaContentDTO, Integer> getTrendMediaContentByYear(int year, Integer limit) throws DAOException {
    int n = limit == null ? 5 : limit;
    try (Session session = getSession()) {
        LocalDate startDate = LocalDate.of(year, 1, 1);
        LocalDate endDate = LocalDate.of(year + 1, 1, 1);

        String query = """
        MATCH (m:Manga)<-[r:LIKE]-(u:User)
        WHERE r.date >= date($startDate) AND r.date < date($endDate)
        WITH m, count(r) AS numLikes
        ORDER BY numLikes DESC
        RETURN m AS manga, numLikes
        LIMIT $n
        """;

        Value params = parameters("startDate", startDate, "endDate", endDate, "n", n);

        Map<MediaContentDTO, Integer> result = new LinkedHashMap<>();
        session.executeRead(
                tx -> tx.run(query, params).list()
        ).forEach(record -> {
            MangaDTO mangaDTO = (MangaDTO) recordToMediaContentDTO(record);
            Integer likes = record.get("numLikes").asInt();
            result.put(mangaDTO, likes);
        });

        return result;

    } catch (Neo4jException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());

    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Neo4j Query:
\end{itemize}
\begin{lstlisting}[language=Cypher]
MATCH (a:Anime)<-[r:LIKE]-(u:User)
WHERE r.date >= $startDate AND r.date < $endDate
WITH a, count(r) AS numLikes
ORDER BY numLikes DESC
RETURN a AS anime, numLikes
LIMIT $n
\end{lstlisting}
\textbf{Get Media Content Trend By Likes}\\
Retrieves a list of trending MangaDTO objects by likes from the Neo4j database.
The method performs the following steps:\\
1. Retrieve the trending Manga by likes in the last 6 months.\\
2. If there are not enough trending Manga, retrieve more results from the last year.\\
3. If there are still not enough trending Manga, retrieve more results from the last 5 years.\\
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public List<MediaContentDTO> getMediaContentTrendByLikes(Integer limit) throws DAOException {
    try (Session session = getSession()) {
        int n = limit == null ? 5 : limit;
        int remaining;
        LocalDate now = LocalDate.now();

        // Try to get trending content based on likes in the last 6 months
        String query1 = """
            MATCH (u:User)-[r:LIKE]->(m:Manga)
            WHERE r.date >= date($startDate)
            WITH m, COUNT(r) AS numLikes
            WHERE numLikes > 10
            RETURN m AS manga, numLikes
            ORDER BY numLikes DESC, m.title ASC
            LIMIT $n
            """;

        Value params1 = parameters("startDate", now.minusMonths(6), "n", n);
        List<MediaContentDTO> trendingContent = session.executeRead(
                        tx -> tx.run(query1, params1).list()
                ).stream()
                .map(record -> (MangaDTO) recordToMediaContentDTO(record))
                .collect(Collectors.toList());

        remaining = n - trendingContent.size();

        // If not enough results, add more results from the last year
        if (remaining > 0) {
            Value params2 = parameters("startDate", now.minusYears(1), "n", remaining);

            List<Record> records = session.executeRead(tx -> tx.run(query1, params2).list());
            for (Record record : records) {
                MangaDTO mangaDTO = (MangaDTO) recordToMediaContentDTO(record);
                if (!trendingContent.contains(mangaDTO))
                    trendingContent.add(mangaDTO);
                if (trendingContent.size() == n)
                    break;
            }

            remaining = n - trendingContent.size();
        }

        // If still not enough results, add more results from the last 5 years
        if (remaining > 0) {
            String query2 = """
            MATCH (u:User)-[r:LIKE]->(m:Manga)
            WHERE r.date >= date($startDate)
            WITH m, COUNT(r) AS numLikes
            RETURN m AS manga, numLikes
            ORDER BY numLikes DESC, m.title ASC
            LIMIT $n
            """;
            Value params3 = parameters("startDate", now.minusYears(5), "n", remaining);

            List<Record> records = session.executeRead(tx -> tx.run(query2, params3).list());
            for (Record record : records) {
                MangaDTO mangaDTO = (MangaDTO) recordToMediaContentDTO(record);
                if (!trendingContent.contains(mangaDTO))
                    trendingContent.add(mangaDTO);
                if (trendingContent.size() == n)
                    break;
            }
        }

        return trendingContent.isEmpty() ? null : trendingContent;

    } catch (Neo4jException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());

    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Neo4j Query:
\end{itemize}
\begin{lstlisting}[language=Cypher]
MATCH (u:User)-[r:LIKE]->(a:Anime)
WHERE r.date >= $startDate
WITH a, COUNT(r) AS numLikes
ORDER BY numLikes DESC
RETURN a AS anime, numLikes
LIMIT $n
\end{lstlisting}
\textbf{Get Suggested By Followings}\\
Retrieves a list of suggested MangaDTO objects for a user from the Neo4j database.
The method performs the following steps:\\
1. Retrieve Manga that the user's followings have liked in the last 6 months.\\
2. If there are not enough suggestions, retrieve Manga that the user's followings have liked in the last 2 years.\\
3. If there are still not enough suggestions, retrieve Manga that the user's followings have liked.
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public List<MediaContentDTO> getSuggestedByFollowings(String userId, Integer limit) throws DAOException {
    try (Session session = getSession()) {
        int n = limit == null ? 5 : limit;
        int remaining;
        LocalDate now = LocalDate.now();

        // try to get suggestions based on likes in the last 6 months
        String query1 = """
            MATCH (u:User {id: $userId})-[:FOLLOWS]->(f:User)-[r:LIKE]->(m:Manga)
            WHERE NOT (u)-[:LIKE]->(m) AND r.date >= date($startDate)
            WITH m, COUNT(DISTINCT f) AS num_likes
            RETURN m AS manga
            ORDER BY num_likes DESC, m.title ASC
            LIMIT $n
            """;
        Value params1 = parameters("userId", userId, "n", n, "startDate", now.minusMonths(6));

        List<MediaContentDTO> suggested = session.executeRead(
                        tx -> tx.run(query1, params1).list()
                ).stream()
                .map(record -> (MangaDTO) recordToMediaContentDTO(record))
                .collect(Collectors.toList());

        remaining = n - suggested.size();

        // if there are not enough suggestions, add more results from the last 2 years
        if (remaining > 0) {
            Value params2 = parameters("userId", userId, "n", n, "startDate", now.minusYears(2));

            List<Record> records = session.executeRead(tx -> tx.run(query1, params2).list());
            for (Record record : records) {
                MangaDTO mangaDTO = (MangaDTO) recordToMediaContentDTO(record);
                if (!suggested.contains(mangaDTO))
                    suggested.add(mangaDTO);
                if (suggested.size() == n)
                    break;
            }

            remaining = n - suggested.size();
        }

        // if there are still not enough suggestions, add more results based on all likes
        if (remaining > 0) {
            String query2 = """
                MATCH (u:User {id: $userId})-[:FOLLOWS]->(f:User)-[r:LIKE]->(m:Manga)
                WHERE NOT (u)-[:LIKE]->(m)
                WITH m, COUNT(DISTINCT f) AS num_likes
                RETURN m AS manga
                ORDER BY num_likes DESC, m.title ASC
                LIMIT $n
                """;
            Value params3 = parameters("userId", userId, "n", n);

            List<Record> records = session.executeRead(tx -> tx.run(query2, params3).list());
            for (Record record : records) {
                MangaDTO mangaDTO = (MangaDTO) recordToMediaContentDTO(record);
                if (!suggested.contains(mangaDTO))
                    suggested.add(mangaDTO);
                if (suggested.size() == n)
                    break;
            }
        }

        return suggested.isEmpty() ? null : suggested;

    } catch (Neo4jException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());

    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Neo4j Query:
\end{itemize}
\begin{lstlisting}[language=Cypher]
MATCH (u:User {id: $userId})-[:FOLLOWS]->(f:User)-[r:LIKE]->(a:Anime)
WHERE NOT (u)-[:LIKE]->(a) AND r.date >= $startDate
WITH a, COUNT(DISTINCT f) AS num_likes
RETURN a AS anime
ORDER BY num_likes DESC
LIMIT $n
\end{lstlisting}
\textbf{Get Suggested By Likes}\\
Retrieves a list of suggested MangaDTO objects for a user from the Neo4j database.
The method performs the following steps:\\
1. Retrieve Manga that other users with similar taste have liked in the last 6 months.\\
2. If there are not enough suggestions, retrieve Manga that other users with similar taste have liked in the last 2 years.\\
3. If there are still not enough suggestions, retrieve Manga that other users with similar taste have liked.\\
\begin{itemize}
    \item Java Implementation:
\end{itemize}
\begin{lstlisting}[language=JavaScript]
public List<MediaContentDTO> getSuggestedByLikes(String userId, Integer limit) throws DAOException {
    try (Session session = getSession()) {
        int n = limit == null ? 5 : limit;
        int remaining;
        LocalDate today = LocalDate.now();

        // Try to get suggestions based on likes in the last 6 months
        String query1 = """
                MATCH (u:User {id: $userId})-[r1:LIKE]->(m:Manga)<-[:LIKE]-(f:User)
                WHERE r1.date >= $startDate
                WITH u, f, COUNT(m) AS common_likes
                ORDER BY common_likes DESC
                LIMIT 20
                MATCH (f)-[:LIKE]->(m2:Manga)
                WHERE NOT (u)-[:LIKE]->(m2)
                WITH m2, COUNT(DISTINCT f) AS num_likes
                RETURN m2 AS manga
                ORDER BY num_likes DESC, m2.title ASC
                LIMIT $n
                """;
        Value params1 = parameters("userId", userId, "n", n, "startDate", today.minusMonths(6));

        List<MediaContentDTO> suggested = session.executeRead(
                        tx -> tx.run(query1, params1).list()
                ).stream()
                .map(record -> (MangaDTO) recordToMediaContentDTO(record))
                .collect(Collectors.toList());

        remaining = n - suggested.size();

        // If there are not enough suggestions, add more results from the last 2 years
        if (remaining > 0) {
            Value params2 = parameters("userId", userId, "n", n, "startDate", today.minusYears(2));

            List<Record> records = session.executeRead(tx -> tx.run(query1, params2).list());
            for (Record record : records) {
                MangaDTO mangaDTO = (MangaDTO) recordToMediaContentDTO(record);
                if (!suggested.contains(mangaDTO))
                    suggested.add(mangaDTO);
                if (suggested.size() == n)
                    break;
            }

            remaining = n - suggested.size();
        }

        // If there are not enough suggestions, add more results based on all likes
        if (remaining > 0) {
            String query2 = """
                    MATCH (u:User {id: $userId})-[r1:LIKE]->(m:Manga)<-[:LIKE]-(f:User)
                    WITH u, f, COUNT(m) AS common_likes
                    ORDER BY common_likes DESC
                    MATCH (f)-[:LIKE]->(m2:Manga)
                    WHERE NOT (u)-[:LIKE]->(m2)
                    WITH m2, COUNT(DISTINCT f) AS num_likes
                    RETURN m2 AS manga
                    ORDER BY num_likes DESC, m2.title ASC
                    LIMIT $n
                    """;
            Value params3 = parameters("userId", userId, "n", n);

            List<Record> records = session.executeRead(tx -> tx.run(query2, params3).list());
            for (Record record : records) {
                MangaDTO mangaDTO = (MangaDTO) recordToMediaContentDTO(record);
                if (!suggested.contains(mangaDTO))
                    suggested.add(mangaDTO);
                if (suggested.size() == n)
                    break;
            }
        }

        return suggested.isEmpty() ? null : suggested;

    } catch (Neo4jException e) {
        throw new DAOException(DAOExceptionType.DATABASE_ERROR, e.getMessage());

    } catch (Exception e) {
        throw new DAOException(DAOExceptionType.GENERIC_ERROR, e.getMessage());
    }
}
\end{lstlisting}
\begin{itemize}
    \item Neo4j Query:
\end{itemize}
\begin{lstlisting}[language=Cypher]
MATCH (u:User {id: $userId})-[r1:LIKE]->(a:Anime)<-[:LIKE]-(f:User)
WHERE r1.date >= $startDate
WITH u, f, COUNT(a) AS common_likes
ORDER BY common_likes DESC
LIMIT 20
MATCH (f)-[:LIKE]->(a2:Anime)
WHERE NOT (u)-[:LIKE]->(a2)
WITH a2, COUNT(DISTINCT f) AS num_likes
RETURN a2 AS anime
ORDER BY num_likes DESC
LIMIT $n
\end{lstlisting}





